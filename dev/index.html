<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · alfa.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">alfa.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NilsKintscher/alfa.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="alfa.jl-1"><a class="docs-heading-anchor" href="#alfa.jl-1">alfa.jl</a><a class="docs-heading-anchor-permalink" href="#alfa.jl-1" title="Permalink"></a></h1><ul><li><a href="#alfa.Lattice-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}} where T&lt;:Union{Float64, Rational} where N"><code>alfa.Lattice</code></a></li><li><a href="#Base.getindex-Tuple{alfa.Lattice,Vararg{Any,N} where N}"><code>Base.getindex</code></a></li><li><a href="#Base.getproperty-Tuple{alfa.Lattice,Symbol}"><code>Base.getproperty</code></a></li><li><a href="#Base.lcm-Union{Tuple{T}, Tuple{X}, Tuple{StaticArrays.MArray{X,T,N,L} where L where N,StaticArrays.MArray{X,T,N,L} where L where N}} where T&lt;:Real where X"><code>Base.lcm</code></a></li><li><a href="#Base.size-Tuple{alfa.Lattice}"><code>Base.size</code></a></li><li><a href="#alfa.CheckIfNormal-Tuple{Any,Any}"><code>alfa.CheckIfNormal</code></a></li><li><a href="#alfa.ElementsInQuotientSpace-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L},Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N"><code>alfa.ElementsInQuotientSpace</code></a></li><li><a href="#alfa.ShiftIntoUnitCell-Union{Tuple{T}, Tuple{N}, Tuple{Any,Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N"><code>alfa.ShiftIntoUnitCell</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="alfa.Lattice-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}} where T&lt;:Union{Float64, Rational} where N" href="#alfa.Lattice-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}} where T&lt;:Union{Float64, Rational} where N"><code>alfa.Lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Lattice{N,T}(A=nothing)</code></pre><p>Construct a <code>Lattice{N,T}</code> with basis <span>$A$</span>, i.e., it represents the set</p><div>\[Aℤ^N = \left\{ ∑_{i=0}^n z_j ⋅ a_j  : z_j ∈ ℤ \right\},\]</div><p>where <span>$a_j$</span> denotes the <span>$j$</span>th column of <span>$A$</span>. Thus, <span>$A$</span> must be square and nonsingular. <code>T&lt;:Union{Float64,Rational}</code> represents the datatype of the entries of the basi <span>$a_{ij}$</span>.</p><p>In case of A==nothing, the identity I of size N is used.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.Lattice{3,Float64}()
alfa.Lattice{3,Float64}([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])

julia&gt; L = alfa.Lattice{2,Rational{BigInt}}()
alfa.Lattice{2,Rational{BigInt}}(Rational{BigInt}[1//1 0//1; 0//1 1//1])

julia&gt; L = alfa.Lattice{2,Rational{BigInt}}([1 2; 3 4])
alfa.Lattice{2,Rational{BigInt}}(Rational{BigInt}[1//1 2//1; 3//1 4//1])

julia&gt; L = alfa.Lattice{2,Rational{BigInt}}([1 2; 1 2])
ERROR: AssertionError: Basis must be nonsingular</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4dfbbf116ac4097675ac2a98677e227c65d483f1/src/lattice.jl#LL13-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{alfa.Lattice,Vararg{Any,N} where N}" href="#Base.getindex-Tuple{alfa.Lattice,Vararg{Any,N} where N}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.getindex(L::Lattice, y...)</code></pre><p>simply wrapping getindex(L.A, y...).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.Lattice{2,Float64}([1 2; 3 4])
alfa.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])
julia&gt; L[1,2] == L.A[1,2]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4dfbbf116ac4097675ac2a98677e227c65d483f1/src/lattice.jl#LL74-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Tuple{alfa.Lattice,Symbol}" href="#Base.getproperty-Tuple{alfa.Lattice,Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.getproperty(L::Lattice, sym::Symbol)</code></pre><p>Get properties of Lattice{N,T}. Let <span>$A=$</span>L.A, i.e., <span>$A ∈ T^{N × N}$</span>, then</p><ul><li>L.n and L.dim return the dimension N.</li><li>L.iA returns <span>$A^{-1}$</span>, i.e., the <em>inverse</em> of the lattice basis</li><li>L.dA returns <span>$A^{-T}$</span>, i.e., the basis of the <em>dual</em> lattice.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.Lattice{2,Float64}([1 2; 3 4])
alfa.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])
julia&gt; L.n == L.dim == typeof(L).parameters[1] == 2
true
julia&gt; L[2,1]
3.0
julia&gt; L.iA == inv(L.A)
true
julia&gt; L.dA == transpose(inv(L.A))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4dfbbf116ac4097675ac2a98677e227c65d483f1/src/lattice.jl#LL91-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.lcm-Union{Tuple{T}, Tuple{X}, Tuple{StaticArrays.MArray{X,T,N,L} where L where N,StaticArrays.MArray{X,T,N,L} where L where N}} where T&lt;:Real where X" href="#Base.lcm-Union{Tuple{T}, Tuple{X}, Tuple{StaticArrays.MArray{X,T,N,L} where L where N,StaticArrays.MArray{X,T,N,L} where L where N}} where T&lt;:Real where X"><code>Base.lcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.lcm(A::MArray{X,T},B::MArray{X,T}...)
Base.lcm(A::MArray{X,T}, B::MArray{X,T}...) where {X,T&lt;:Rational}

Base.lcm(A::Lattice{N,T}, B::Lattice{N,T}...) where {N,T}
Base.lcm(A::MArray{X,T}, B::MArray{X,T}...) where {X,T&lt;:Rational}</code></pre><p>Returns the least common multiple of <span>$A$</span> and <span>$B$</span> (or more), i.e. a sub-lattice <span>$C$</span>, that is <span>$C ⊂ A$</span> and <span>$C ⊂ B$</span> with <span>$|\det(C)|$</span> as small as possible.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.Lattice{2,Float64}([1 2; 3 4])
alfa.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])

julia&gt; alfa.lcm(L) == L
true

julia&gt; alfa.lcm(L.A) == L.A
true

julia&gt; alfa.lcm(alfa.Lattice{1,Float64}([2]), alfa.Lattice{1,Float64}([3]), alfa.Lattice{1,Float64}([6]))
alfa.Lattice{1,Float64}([6.0])

julia&gt; alfa.lcm(alfa.Lattice{2,Rational{BigInt}}([1 1; -1 1]), alfa.Lattice{2,Rational{BigInt}}([1 2; 2 1]))
alfa.Lattice{2,Rational{BigInt}}(Rational{BigInt}[-3//1 1//1; -3//1 -1//1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4dfbbf116ac4097675ac2a98677e227c65d483f1/src/lattice.jl#LL129-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{alfa.Lattice}" href="#Base.size-Tuple{alfa.Lattice}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.size(L::Lattice)</code></pre><p>Returns the dimension of the lattice basis: size(L.A,1).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.Lattice{2,Float64}([1 2; 3 4])
alfa.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])
julia&gt; size(L) == size(L.A) == (2,2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4dfbbf116ac4097675ac2a98677e227c65d483f1/src/lattice.jl#LL57-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.CheckIfNormal-Tuple{Any,Any}" href="#alfa.CheckIfNormal-Tuple{Any,Any}"><code>alfa.CheckIfNormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CheckIfNormal(s, A)</code></pre><p>Checks if s is found within the primtive cell of A, i.e., `<code>A^{-1}s_j ∈ [0,1)^N</code> and if s is sorted lexicographically.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; using LinearAlgebra

julia&gt; L = alfa.Lattice{2,Float64}([1 0; 0 1]);

julia&gt; s = [[-1/2,0], [1/4,2]]
2-element Array{Array{Float64,1},1}:
 [-0.5, 0.0]
 [0.25, 2.0]

julia&gt;  alfa.CheckIfNormal(s,L)
false

julia&gt; t = [[1/4,0], [1/2,0]]
2-element Array{Array{Float64,1},1}:
 [0.25, 0.0]
 [0.5, 0.0]

julia&gt; alfa.CheckIfNormal(t,L)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4dfbbf116ac4097675ac2a98677e227c65d483f1/src/lattice.jl#LL353-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.ElementsInQuotientSpace-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L},Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N" href="#alfa.ElementsInQuotientSpace-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L},Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N"><code>alfa.ElementsInQuotientSpace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ElementsInQuotientSpace(
    A::Union{Matrix{T},MMatrix{N,N,T}},
    B::Union{Matrix{T},MMatrix{N,N,T}};
    return_diag_hnf::Bool = false,
    return_fractional::Bool = false,
) where {N,T}</code></pre><p>Returns all lattice points of the lattice generated by <span>$A$</span> found in the primitive cell of B, i.e.,</p><div>\[T_{A,B}=\{x : x ∈ A \mathbb{Z}^N \cap B[0,1)^N \}\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; A = alfa.Lattice{2,Float64}([1 0; 0 1]);

julia&gt; B = alfa.Lattice{2,Float64}([2 0; 0 2]);

julia&gt; alfa.ElementsInQuotientSpace(A.A,B.A)
4-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
 [1.0, 0.0]
 [0.0, 1.0]
 [1.0, 1.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4dfbbf116ac4097675ac2a98677e227c65d483f1/src/lattice.jl#LL198-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.ShiftIntoUnitCell-Union{Tuple{T}, Tuple{N}, Tuple{Any,Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N" href="#alfa.ShiftIntoUnitCell-Union{Tuple{T}, Tuple{N}, Tuple{Any,Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N"><code>alfa.ShiftIntoUnitCell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ShiftIntoUnitCell(s, A::Union{Matrix{T},MMatrix{N,N,T}}) where {N,T}
ShiftIntoUnitCell(s, A::Union{Matrix{T},MMatrix{N,N,T}}) where {N,T&lt;:Rational}
ShiftIntoUnitCell(s, A::Lattice)</code></pre><p>Shifts all elements s[i] into the primitive cell <span>$A[0,1)^N$</span> and sort the entries lexicographically. The function returns t, y, p, such that</p><div>\[t_j + A y_j = s_{p(j)}\]</div><ul><li>s is the shifted vector s, i.e., <span>$A^{-1}s_j ∈ [0,1)^N$</span> for all j.</li><li>p is the permutation with respect to the input s.</li><li>y corresponds to the shift in fractional coordinates</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; using LinearAlgebra

julia&gt; L = alfa.Lattice{2,Float64}([1 0; 0 1]);

julia&gt; s = [[-1/2,0], [1/4,2]]
2-element Array{Array{Float64,1},1}:
 [-0.5, 0.0]
 [0.25, 2.0]

julia&gt; (t, y, p) = alfa.ShiftIntoUnitCell(s,L);

julia&gt; t
2-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.25, 0.0]
 [0.5, 0.0]

julia&gt; y
2-element Array{StaticArrays.MArray{Tuple{2},Float64,1,2},1}:
 [0.0, 2.0]
 [-1.0, 0.0]

julia&gt; p
2-element Array{Int64,1}:
 2
 1

julia&gt; [t[j] + L.A*y[j] - s[p[j]] for j in [1,2]]
2-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
 [0.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4dfbbf116ac4097675ac2a98677e227c65d483f1/src/lattice.jl#LL260-L309">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 30 March 2020 16:57">Monday 30 March 2020</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
