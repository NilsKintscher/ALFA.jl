<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · ALFA.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ALFA.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/example_01/">Example 1: Tutorial</a></li><li><a class="tocitem" href="../../examples/example_02/">Example 2: Colored overlapping smoother for graphene</a></li><li><a class="tocitem" href="../../examples/example_03/">Example 3: Half-hybrid smoother for the curl-curl equation</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../gallery/">Gallery</a></li><li class="is-active"><a class="tocitem" href>Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NilsKintscher/ALFA.jl/blob/master/docs/src/internals/internals.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h1><ul><li><a href="#ALFA.Crystal-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}, Tuple{Any,Any}, Tuple{Any,Any,Any}} where T&lt;:Union{Float64, Rational} where N"><code>ALFA.Crystal</code></a></li><li><a href="#ALFA.CrystalOperator-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.Crystal{N,T},LinearAlgebra.UniformScaling}, Tuple{ALFA.Crystal{N,T},LinearAlgebra.UniformScaling,Any}} where T where N"><code>ALFA.CrystalOperator</code></a></li><li><a href="#ALFA.Lattice-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}} where T&lt;:Union{Float64, Rational} where N"><code>ALFA.Lattice</code></a></li><li><a href="#ALFA.Multiplier-Union{Tuple{}, Tuple{Any}, Tuple{N}, Tuple{Any,Any}} where N"><code>ALFA.Multiplier</code></a></li><li><a href="#ALFA.OperatorComposition-Tuple{Expr}"><code>ALFA.OperatorComposition</code></a></li><li><a href="#ALFA.CheckIfNormal-Tuple{Any,Any}"><code>ALFA.CheckIfNormal</code></a></li><li><a href="#ALFA.CleanUp!-Tuple{ALFA.CrystalOperator}"><code>ALFA.CleanUp!</code></a></li><li><a href="#ALFA.CrystalOperatorCopyLowerTriangle-Union{Tuple{ALFA.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>ALFA.CrystalOperatorCopyLowerTriangle</code></a></li><li><a href="#ALFA.CrystalOperatorCopyWithMultipliers-Union{Tuple{ALFA.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>ALFA.CrystalOperatorCopyWithMultipliers</code></a></li><li><a href="#ALFA.ElementsInQuotientSpace-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L},Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N"><code>ALFA.ElementsInQuotientSpace</code></a></li><li><a href="#ALFA.ShiftIntoStandardCell-Union{Tuple{T}, Tuple{N}, Tuple{Any,Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N"><code>ALFA.ShiftIntoStandardCell</code></a></li><li><a href="#ALFA.construct_matrix-Tuple{ALFA.CrystalOperator,ALFA.Lattice}"><code>ALFA.construct_matrix</code></a></li><li><a href="#ALFA.eigen-Union{Tuple{X}, Tuple{X,Any}} where X&lt;:Union{ALFA.OperatorComposition, ALFA.CrystalOperator}"><code>ALFA.eigen</code></a></li><li><a href="#ALFA.eigvals-Tuple{X} where X&lt;:Union{ALFA.OperatorComposition, ALFA.CrystalOperator}"><code>ALFA.eigvals</code></a></li><li><a href="#ALFA.eigvals-Union{Tuple{X}, Tuple{T}, Tuple{X,T}} where X&lt;:Union{ALFA.OperatorComposition, ALFA.CrystalOperator} where T&lt;:Union{Tuple, AbstractArray{T,1} where T}"><code>ALFA.eigvals</code></a></li><li><a href="#ALFA.eigvals_df-Tuple{X} where X&lt;:Union{ALFA.OperatorComposition, ALFA.CrystalOperator}"><code>ALFA.eigvals_df</code></a></li><li><a href="#ALFA.find_multiplier-Tuple{ALFA.CrystalOperator,Any}"><code>ALFA.find_multiplier</code></a></li><li><a href="#ALFA.hnf-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M"><code>ALFA.hnf</code></a></li><li><a href="#ALFA.lll-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M"><code>ALFA.lll</code></a></li><li><a href="#ALFA.normalize-Union{Tuple{ALFA.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>ALFA.normalize</code></a></li><li><a href="#ALFA.normalize-Union{Tuple{ALFA.Crystal{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>ALFA.normalize</code></a></li><li><a href="#ALFA.snf_with_transform-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M"><code>ALFA.snf_with_transform</code></a></li><li><a href="#ALFA.symbol-Tuple{ALFA.CrystalOperator,Any}"><code>ALFA.symbol</code></a></li><li><a href="#ALFA.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.Crystal{N,T},Any}} where T where N"><code>ALFA.wrtLattice</code></a></li><li><a href="#ALFA.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.CrystalOperator{N,T},Any}, Tuple{ALFA.CrystalOperator{N,T},Any,Any}, Tuple{ALFA.CrystalOperator{N,T},Any,Any,Any}} where T where N"><code>ALFA.wrtLattice</code></a></li><li><a href="#ALFA.wrtSameLatticeAndNormalize-Tuple{ALFA.CrystalOperator,ALFA.CrystalOperator}"><code>ALFA.wrtSameLatticeAndNormalize</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{T,ALFA.CrystalOperator}} where T&lt;:Number"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.CrystalOperator{N,T},ALFA.CrystalOperator{N,T}}} where T where N"><code>Base.:*</code></a></li><li><a href="#Base.:+-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.CrystalOperator{N,T},ALFA.CrystalOperator{N,T}}} where T where N"><code>Base.:+</code></a></li><li><a href="#Base.:/-Union{Tuple{T}, Tuple{ALFA.CrystalOperator,T}} where T&lt;:Number"><code>Base.:/</code></a></li><li><a href="#Base.getindex-Tuple{ALFA.Lattice,Vararg{Any,N} where N}"><code>Base.getindex</code></a></li><li><a href="#Base.getproperty-Tuple{ALFA.Lattice,Symbol}"><code>Base.getproperty</code></a></li><li><a href="#Base.lcm-Union{Tuple{T}, Tuple{X}, Tuple{StaticArrays.MArray{X,T,N,L} where L where N,StaticArrays.MArray{X,T,N,L} where L where N}} where T&lt;:Real where X"><code>Base.lcm</code></a></li><li><a href="#Base.push!"><code>Base.push!</code></a></li><li><a href="#Base.size-Tuple{ALFA.Lattice}"><code>Base.size</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ALFA.Crystal-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}, Tuple{Any,Any}, Tuple{Any,Any,Any}} where T&lt;:Union{Float64, Rational} where N" href="#ALFA.Crystal-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}, Tuple{Any,Any}, Tuple{Any,Any,Any}} where T&lt;:Union{Float64, Rational} where N"><code>ALFA.Crystal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Crystal{N,T}(L = nothing, Domain = nothing, Codomain = nothing) where {N,T&lt;:Union{Float64, Rational}}</code></pre><p>Constructs a <code>Crystal{N,T}</code> which respresents the domain and codomain of a CrystalOperator. It consists of a L::Lattice{N,T} and the structure elements Domain::Vector{SVector{N,T}} and Codomain::Vector{SVector{N,T}}.</p><p>This struct describes the set</p><p class="math-container">\[Aℤ^N+s = \left\{ ∑_{i=0}^n z_j ⋅ a_j + (s_1,s_2,\ldots,s_m)  : z_j ∈ ℤ  \right\},\]</p><p>where <span>$s=(s_1,s_2,\ldots,s_m) ∈ \{\text{Domain,Codomain}\}$</span> is the <em>structure element</em>, <span>$A$</span> the lattice basis L.A.</p><ul><li>In case of L==nothing, the identity I of size N is used.</li><li>In case of Domain==nothing, the origin <span>$0 \in \mathbb{R}^N$</span> is used.</li><li>In case Codomain==nothing, Domain is used.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; ALFA.Crystal{2,Float64}()
Lattice Basis: ALFA.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystal.jl#LL17-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.CrystalOperator-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.Crystal{N,T},LinearAlgebra.UniformScaling}, Tuple{ALFA.Crystal{N,T},LinearAlgebra.UniformScaling,Any}} where T where N" href="#ALFA.CrystalOperator-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.Crystal{N,T},LinearAlgebra.UniformScaling}, Tuple{ALFA.Crystal{N,T},LinearAlgebra.UniformScaling,Any}} where T where N"><code>ALFA.CrystalOperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CrystalOperator(
    C::Crystal{N,T},
    J::UniformScaling,
    _CompatibilityCheckOnly = false,
) where {N,T}
CrystalOperator{N,T}(
    C = nothing,
    M = nothing,
    _CompatibilityCheckOnly = false,
) where {N,T&lt;:Union{Float64,Rational}}</code></pre><p>Constructs a translationally invariant <code>C::CrystalOperators{N,T}</code></p><p class="math-container">\[C : \mathcal{L}(C.L^\text{Domain}) \rightarrow \mathcal{L}(C.L^\text{Codomain})\]</p><p>The actual function definition <span>$(Cf)(x)$</span> is saved within <code>C.M::SortedSet{Multiplier}</code>:</p><p class="math-container">\[(Cf)(x) = \sum_{y \in C.M} y.\text{mat} ⋅ f(x+y.\text{pos}) \quad \forall x \in (C.L.A)\mathbb{Z}^N\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; using LinearAlgebra

julia&gt; ALFA.CrystalOperator{2,Float64}()
Lattice Basis: ALFA.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: ALFA.Multiplier[]

julia&gt; ALFA.CrystalOperator(ALFA.Crystal{2,Float64}(),3*I)
Lattice Basis: ALFA.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 1-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{2}([0, 0], [3])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL16-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.Lattice-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}} where T&lt;:Union{Float64, Rational} where N" href="#ALFA.Lattice-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}} where T&lt;:Union{Float64, Rational} where N"><code>ALFA.Lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Lattice{N,T}(A=nothing)</code></pre><p>Construct a <code>Lattice{N,T}</code> with basis <span>$A$</span>, i.e., it represents the set</p><p class="math-container">\[Aℤ^N = \left\{ ∑_{i=0}^n z_j ⋅ a_j  : z_j ∈ ℤ \right\},\]</p><p>where <span>$a_j$</span> denotes the <span>$j$</span>th column of <span>$A$</span>. The matrix <span>$A$</span> must be square and nonsingular:</p><ul><li><span>$A$</span> is called the <em>lattice basis</em>.</li><li><span>$a_j$</span> are the <em>primite vectors</em> of the lattice.</li></ul><p><code>T&lt;:Union{Float64,Rational}</code> represents the datatype of the entries of the basis <span>$a_{ij}$</span>.</p><p>In case of A==nothing, the identity I of size N is used.</p><p>See Definition 2.1 in [1].</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; L = ALFA.Lattice{3,Float64}()
ALFA.Lattice{3,Float64}([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])

julia&gt; L = ALFA.Lattice{2,Rational{BigInt}}()
ALFA.Lattice{2,Rational{BigInt}}(Rational{BigInt}[1//1 0//1; 0//1 1//1])

julia&gt; L = ALFA.Lattice{2,Rational{BigInt}}([1 2; 3 4])
ALFA.Lattice{2,Rational{BigInt}}(Rational{BigInt}[1//1 2//1; 3//1 4//1])

julia&gt; L = ALFA.Lattice{2,Rational{BigInt}}([1 2; 1 2])
ERROR: AssertionError: Basis must be nonsingular</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/lattice.jl#LL13-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.Multiplier-Union{Tuple{}, Tuple{Any}, Tuple{N}, Tuple{Any,Any}} where N" href="#ALFA.Multiplier-Union{Tuple{}, Tuple{Any}, Tuple{N}, Tuple{Any,Any}} where N"><code>ALFA.Multiplier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Multiplier{N}(pos = nothing, mat = nothing) where {N}
Multiplier(pos = nothing, mat = nothing)</code></pre><p>Constructs a multiplication matrix as part of a CrystalOperator. The position is given in fractional coordinates and thus (converted to) integral.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; ALFA.Multiplier([0 0], [1 2 3; 4 5 6])
Position: 2-element StaticArrays.MArray{Tuple{2},Int64,1,2} with indices SOneTo(2):
 0
 0
Multiplier: 2×3 Array{Int64,2}:
 1  2  3
 4  5  6
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/multiplier.jl#LL12-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.OperatorComposition-Tuple{Expr}" href="#ALFA.OperatorComposition-Tuple{Expr}"><code>ALFA.OperatorComposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperatorComposition(f::Expr)</code></pre><p>Constructs a struct OperatorComposition from an expression. All CrystalOperators     are rewritten with respect to a single translationally invariance and normalized.     Furthermore, it is checked if the expression is well-defined.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; L = ALFA.gallery.Laplace(N=1);

julia&gt; f = :(inv($L)*$L);

julia&gt; oc = ALFA.OperatorComposition(f);

julia&gt; ALFA.symbol(oc,[randn(1)]) ≈ [1] # as f is the identitity, the fourier transform is 1 for all frequencies.
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/operatorcomposition.jl#LL9-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.CheckIfNormal-Tuple{Any,Any}" href="#ALFA.CheckIfNormal-Tuple{Any,Any}"><code>ALFA.CheckIfNormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CheckIfNormal(s, A)</code></pre><p>Checks if s is found within the primtive cell of A, i.e., <span>$A^{-1}s_j ∈ [0,1)^N$</span> and if s is sorted lexicographically.</p><p>See Definition 5.4 in [1].</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; using LinearAlgebra

julia&gt; L = ALFA.Lattice{2,Float64}([1 0; 0 1]);

julia&gt; s = [[-1/2,0], [1/4,2]]
2-element Array{Array{Float64,1},1}:
 [-0.5, 0.0]
 [0.25, 2.0]

julia&gt;  ALFA.CheckIfNormal(s,L)
false

julia&gt; t = [[1/4,0], [1/2,0]]
2-element Array{Array{Float64,1},1}:
 [0.25, 0.0]
 [0.5, 0.0]

julia&gt; ALFA.CheckIfNormal(t,L)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/lattice.jl#LL360-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.CleanUp!-Tuple{ALFA.CrystalOperator}" href="#ALFA.CleanUp!-Tuple{ALFA.CrystalOperator}"><code>ALFA.CleanUp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CleanUp!(S::CrystalOperator)</code></pre><p>Removes all multipliers m with norm(m.mat) == 0.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; using LinearAlgebra

julia&gt; S = ALFA.CrystalOperator(ALFA.Crystal{2,Float64}(),0*I)
Lattice Basis: ALFA.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 1-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{2}([0, 0], [0])

julia&gt; ALFA.CleanUp!(S)

julia&gt; S
Lattice Basis: ALFA.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: ALFA.Multiplier[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL413-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.CrystalOperatorCopyLowerTriangle-Union{Tuple{ALFA.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N" href="#ALFA.CrystalOperatorCopyLowerTriangle-Union{Tuple{ALFA.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>ALFA.CrystalOperatorCopyLowerTriangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CrystalOperatorCopyLowerTriangle(S::CrystalOperator{N,T}; idx = nothing, omega=1.0) where {N,T}</code></pre><p>Returns the CrystalOperator G consisting of the central multiplier of S:     m<em>G^{(0)} = p@m</em>L^{(pos)}@p if pos ≦ 0,     m_G^{(y)} = 0 if pos &gt; 0.</p><pre><code class="language-none">with P[i,j] = 1 if i=j in idx,
    = 0 else.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL179-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.CrystalOperatorCopyWithMultipliers-Union{Tuple{ALFA.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N" href="#ALFA.CrystalOperatorCopyWithMultipliers-Union{Tuple{ALFA.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>ALFA.CrystalOperatorCopyWithMultipliers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CrystalOperatorCopyWithMultipliers(S::CrystalOperator{N,T}; pos = nothing, idx = nothing) where {N,T}</code></pre><p>Returns the CrystalOperator G consisting of the central multiplier of S:     m<em>G^{(0)} = p@m</em>L^{(pos)}@p,     m_G^{(y)} = 0 if y != pos,</p><pre><code class="language-none">with P[i,j] = 1 if i=j in idx,
    = 0 else.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL144-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.ElementsInQuotientSpace-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L},Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N" href="#ALFA.ElementsInQuotientSpace-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L},Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N"><code>ALFA.ElementsInQuotientSpace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ElementsInQuotientSpace(
    A::Union{Matrix{T},MMatrix{N,N,T}},
    B::Union{Matrix{T},MMatrix{N,N,T}};
    return_diag_hnf::Bool = false,
    return_fractional::Bool = false,
) where {N,T}</code></pre><p>Returns all lattice points of the lattice generated by <span>$A$</span> found in the primitive cell of B, i.e.,</p><p class="math-container">\[T_{A,B}=\{x : x ∈ A \mathbb{Z}^N \cap B[0,1)^N \}\]</p><p>See Algorithm B.3, Theorem 2.3 in [1].</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; A = ALFA.Lattice{2,Float64}([1 0; 0 1]);

julia&gt; B = ALFA.Lattice{2,Float64}([2 0; 0 2]);

julia&gt; ALFA.ElementsInQuotientSpace(A.A,B.A)
4-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
 [1.0, 0.0]
 [0.0, 1.0]
 [1.0, 1.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/lattice.jl#LL203-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.ShiftIntoStandardCell-Union{Tuple{T}, Tuple{N}, Tuple{Any,Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N" href="#ALFA.ShiftIntoStandardCell-Union{Tuple{T}, Tuple{N}, Tuple{Any,Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N"><code>ALFA.ShiftIntoStandardCell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ShiftIntoStandardCell(s, A::Union{Matrix{T},MMatrix{N,N,T}}) where {N,T}
ShiftIntoStandardCell(s, A::Union{Matrix{T},MMatrix{N,N,T}}) where {N,T&lt;:Rational}
ShiftIntoStandardCell(s, A::Lattice)</code></pre><p>Shifts all elements s[i] into the primitive cell <span>$A[0,1)^N$</span> and sort the entries lexicographically. The function returns t, y, p, such that</p><p class="math-container">\[t_j + A y_j = s_{p(j)}\]</p><ul><li>t is the shifted vector s, i.e., <span>$A^{-1}t_j ∈ [0,1)^N$</span> for all j.</li><li>p is the permutation with respect to the input s.</li><li>y corresponds to the shift in fractional coordinates.</li></ul><p>See Definition 2.2, 5.2  in [1].</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; using LinearAlgebra

julia&gt; L = ALFA.Lattice{2,Float64}([1 0; 0 1]);

julia&gt; s = [[-1/2,0], [1/4,2]]
2-element Array{Array{Float64,1},1}:
 [-0.5, 0.0]
 [0.25, 2.0]

julia&gt; (t, y, p) = ALFA.ShiftIntoStandardCell(s,L);

julia&gt; t
2-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.25, 0.0]
 [0.5, 0.0]

julia&gt; y
2-element Array{StaticArrays.MArray{Tuple{2},Float64,1,2},1}:
 [0.0, 2.0]
 [-1.0, 0.0]

julia&gt; p
2-element Array{Int64,1}:
 2
 1

julia&gt; [t[j] + L.A*y[j] - s[p[j]] for j in [1,2]]
2-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
 [0.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/lattice.jl#LL266-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.construct_matrix-Tuple{ALFA.CrystalOperator,ALFA.Lattice}" href="#ALFA.construct_matrix-Tuple{ALFA.CrystalOperator,ALFA.Lattice}"><code>ALFA.construct_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">construct_matrix(x::ALFA.CrystalOperator,wrt::ALFA.Lattice)</code></pre><p>Constructs a matrix from a CrystalOperator with respect to a given Lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL1087-L1091">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.eigen-Union{Tuple{X}, Tuple{X,Any}} where X&lt;:Union{ALFA.OperatorComposition, ALFA.CrystalOperator}" href="#ALFA.eigen-Union{Tuple{X}, Tuple{X,Any}} where X&lt;:Union{ALFA.OperatorComposition, ALFA.CrystalOperator}"><code>ALFA.eigen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigen(S::X, k; by = abs) where {X&lt;:Union{CrystalOperator,OperatorComposition}}</code></pre><p>Computes the eigenvalues and eigenvectors of the symbol of a CrystalOperator/OperatorComposition wrt frequency k.</p><p>The eigenvalues are sorted by <code>by</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/analysis.jl#LL109-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.eigvals-Tuple{X} where X&lt;:Union{ALFA.OperatorComposition, ALFA.CrystalOperator}" href="#ALFA.eigvals-Tuple{X} where X&lt;:Union{ALFA.OperatorComposition, ALFA.CrystalOperator}"><code>ALFA.eigvals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigvals(
    S::X;
    N = 20,
    by = abs,
    unique = false,
    digits = 5,
) where {X&lt;:Union{CrystalOperator,OperatorComposition}}</code></pre><p>Computes the eigenvalues of the symbol of a CrystalOperator/OperatorComposition. The Frequency space is divided into N^dim equidistant (unique) points frequencies k.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/analysis.jl#LL66-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.eigvals-Union{Tuple{X}, Tuple{T}, Tuple{X,T}} where X&lt;:Union{ALFA.OperatorComposition, ALFA.CrystalOperator} where T&lt;:Union{Tuple, AbstractArray{T,1} where T}" href="#ALFA.eigvals-Union{Tuple{X}, Tuple{T}, Tuple{X,T}} where X&lt;:Union{ALFA.OperatorComposition, ALFA.CrystalOperator} where T&lt;:Union{Tuple, AbstractArray{T,1} where T}"><code>ALFA.eigvals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigvals(
    S::X,
    k::T;
    by = abs,
) where {
    T&lt;:Union{AbstractVector,Tuple},
    X&lt;:Union{CrystalOperator,OperatorComposition},
}</code></pre><p>Computes the eigenvalues of the symbol of a CrystalOperator/OperatorComposition wrt frequency k.</p><p>The eigenvalues are sorted by <code>by</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/analysis.jl#LL34-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.eigvals_df-Tuple{X} where X&lt;:Union{ALFA.OperatorComposition, ALFA.CrystalOperator}" href="#ALFA.eigvals_df-Tuple{X} where X&lt;:Union{ALFA.OperatorComposition, ALFA.CrystalOperator}"><code>ALFA.eigvals_df</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigvals_df(S::X; N = 20, by = abs) where {X&lt;:Union{CrystalOperator,OperatorComposition}}</code></pre><p>Returns a dataframe with the eigenvalues of the symbol of a CrystalOperator/OperatorComposition. The Frequency space is divided into N^dim equidistant (unique) points frequencies k.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/analysis.jl#LL123-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.find_multiplier-Tuple{ALFA.CrystalOperator,Any}" href="#ALFA.find_multiplier-Tuple{ALFA.CrystalOperator,Any}"><code>ALFA.find_multiplier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_multiplier(S::CrystalOperator, pos)</code></pre><p>Returns the multiplier at pos if existent (in S.M).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; S = ALFA.gallery.Laplace()
Lattice Basis: ALFA.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 5-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{2}([-1, 0], [1.0])
 ALFA.Multiplier{2}([0, -1], [1.0])
 ALFA.Multiplier{2}([0, 0], [-4.0])
 ALFA.Multiplier{2}([0, 1], [1.0])
 ALFA.Multiplier{2}([1, 0], [1.0])

julia&gt; ALFA.find_multiplier(S, [0, 0])
Position: 2-element StaticArrays.MArray{Tuple{2},Int64,1,2} with indices SOneTo(2):
 0
 0
Multiplier: 1×1 Array{Float64,2}:
 -4.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL104-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.hnf-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M" href="#ALFA.hnf-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M"><code>ALFA.hnf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hnf(mat::MMatrix{M,N}) where {M, N}
hnf(mat::Matrix)</code></pre><p>Wrapper of Nemo.hnf. Input is converted to BigInt. Returns H = mat*U, s.t. H is in Hermite Normal Form and U is unimodular.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA # hide

julia&gt; using LinearAlgebra # hide

julia&gt; mat = rand(1:1000, 2, 2);

julia&gt; H = ALFA.hnf(mat);

julia&gt; norm(LinearAlgebra.tril(H) - H) ≈ 0
true
julia&gt; round(abs(det(inv(mat)*H)), digits=5)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/nemo_wrapper.jl#LL67-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.lll-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M" href="#ALFA.lll-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M"><code>ALFA.lll</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lll(mat::MMatrix{M,N}) where {M, N}
lll(mat::Matrix)</code></pre><p>Wrapper of Nemo.lll. Input is converted to BigInt. Applies the LLL-Algorithm to the input mat. Computes output L, such that mat*T=L for some unimodular T.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA # hide

julia&gt; using LinearAlgebra # hide

julia&gt; mat = rand(1:1000, 2, 2);

julia&gt; L = ALFA.lll(mat);

julia&gt; round(abs(det(inv(mat)*L)), digits=5)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/nemo_wrapper.jl#LL106-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.normalize-Union{Tuple{ALFA.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N" href="#ALFA.normalize-Union{Tuple{ALFA.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>ALFA.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize(S::CrystalOperator{N,T}) where {N,T}</code></pre><p>Normalizes the crystaloperator, i.e., returns an crystaloperator isomorphic to S where all structure elements are shifted in the standard cell <span>$S.C.L.A\cdot[0,1)^N$</span> and sorted lexicographically.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; S = ALFA.CrystalOperator{1,Float64}(ALFA.Crystal{1,Float64}([1], [-.5], [1.5]))
Lattice Basis: ALFA.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [-0.5]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [1.5]
Multiplier: ALFA.Multiplier[]

julia&gt; push!(S, ALFA.Multiplier([0], [-2]))
Lattice Basis: ALFA.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [-0.5]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [1.5]
Multiplier: 1-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([0], [-2])

julia&gt; ALFA.normalize(S)
Lattice Basis: ALFA.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.5]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.5]
Multiplier: 1-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-2], [-2])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL296-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.normalize-Union{Tuple{ALFA.Crystal{N,T}}, Tuple{T}, Tuple{N}} where T where N" href="#ALFA.normalize-Union{Tuple{ALFA.Crystal{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>ALFA.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize(C::Crystal{N,T}) where {N,T}</code></pre><p>Normalizes the crystal, i.e., shifts the structure elements Domain and Codomain into the standard primitive cell.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; C = ALFA.Crystal{1,Float64}([2], [[-1],[-.5],[-1.5]], [[0]])
Lattice Basis: ALFA.Lattice{1,Float64}([2.0])
Domain: 3-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [-1.0]
 [-0.5]
 [-1.5]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]

julia&gt; ALFA.normalize(C)
Lattice Basis: ALFA.Lattice{1,Float64}([2.0])
Domain: 3-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.5]
 [1.0]
 [1.5]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystal.jl#LL102-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.snf_with_transform-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M" href="#ALFA.snf_with_transform-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M"><code>ALFA.snf_with_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">snf_with_transform(L::Lattice)
snf_with_transform(mat::MMatrix{M,N}) where {M,N}
snf_with_transform(mat::Matrix)</code></pre><p>Wrapper of Nemo.snf<em>with</em>transform. Input is converted to BigInt. Returns (S,U,V) such that U<em>mat</em>V = S, where S is the Smith normal form of mat.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA # hide

julia&gt; using LinearAlgebra # hide

julia&gt; mat = rand(1:10, 10, 10);

julia&gt; (S,U,V) = ALFA.snf_with_transform(mat);

julia&gt; norm(U*mat*V - S) ≈ 0
true

julia&gt; abs(det(U)) ≈ abs(det(V)) ≈ 1
true

julia&gt; norm(diagm(diag(S)) - S) ≈ 0
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/nemo_wrapper.jl#LL19-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.symbol-Tuple{ALFA.CrystalOperator,Any}" href="#ALFA.symbol-Tuple{ALFA.CrystalOperator,Any}"><code>ALFA.symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symbol(S::CrystalOperator, k; π = π)
symbol(O::OperatorComposition, k; π = π)</code></pre><p>Returns the symbol of the CrystalOperator/OperatorComposition for a given frequency/wavevector k.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; L = ALFA.gallery.Laplace(N=2);

julia&gt; oc = ALFA.OperatorComposition(:(3*$L));

julia&gt; ALFA.symbol(oc,[0.5, 0.5]) ≈ [-24] # as f is the identitity, the fourier transform is 1 for all frequencies.
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/analysis.jl#LL1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.CrystalOperator{N,T},Any}, Tuple{ALFA.CrystalOperator{N,T},Any,Any}, Tuple{ALFA.CrystalOperator{N,T},Any,Any,Any}} where T where N" href="#ALFA.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.CrystalOperator{N,T},Any}, Tuple{ALFA.CrystalOperator{N,T},Any,Any}, Tuple{ALFA.CrystalOperator{N,T},Any,Any,Any}} where T where N"><code>ALFA.wrtLattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wrtLattice(
    S::CrystalOperator{N,T},
    A,
    _CompatibilityCheckOnly = false,
    normalize = true
) where {N,T}</code></pre><p>Rewrites the crystaloperator S wit hrespect to the translationally invariance A.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; L = ALFA.gallery.Laplace(N=1)
Lattice Basis: ALFA.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], [1.0])
 ALFA.Multiplier{1}([0], [-2.0])
 ALFA.Multiplier{1}([1], [1.0])

julia&gt; ALFA.wrtLattice(L, L.C.L.A*2)
Lattice Basis: ALFA.Lattice{1,Float64}([2.0])
Domain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Codomain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Multiplier: 3-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], [0.0 1.0; 0.0 0.0])
 ALFA.Multiplier{1}([0], [-2.0 1.0; 1.0 -2.0])
 ALFA.Multiplier{1}([1], [0.0 0.0; 1.0 0.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL452-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.Crystal{N,T},Any}} where T where N" href="#ALFA.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.Crystal{N,T},Any}} where T where N"><code>ALFA.wrtLattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wrtLattice(C::Crystal, L::Lattice)
wrtLattice(C::Crystal{N,T}, A) where {N,T}</code></pre><p>Rewrites the crystal with respect to L::Lattice or lattice basis A. Thus, the lattice must be a sublattice of C.L.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; using LinearAlgebra

julia&gt; C = ALFA.Crystal{2,Float64}()
Lattice Basis: ALFA.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]

julia&gt; L = ALFA.Lattice{2,Float64}(2*I)
ALFA.Lattice{2,Float64}([2.0 0.0; 0.0 2.0])

julia&gt; ALFA.wrtLattice(C,L)
Lattice Basis: ALFA.Lattice{2,Float64}([2.0 0.0; 0.0 2.0])
Domain: 4-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
 [1.0, 0.0]
 [0.0, 1.0]
 [1.0, 1.0]
Codomain: 4-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
 [1.0, 0.0]
 [0.0, 1.0]
 [1.0, 1.0]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystal.jl#LL137-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ALFA.wrtSameLatticeAndNormalize-Tuple{ALFA.CrystalOperator,ALFA.CrystalOperator}" href="#ALFA.wrtSameLatticeAndNormalize-Tuple{ALFA.CrystalOperator,ALFA.CrystalOperator}"><code>ALFA.wrtSameLatticeAndNormalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wrtSameLatticeAndNormalize(A::CrystalOperator, B::CrystalOperator)</code></pre><p>Finds a least common multiple translationally invariance C and rewrites both operators A and B wrt C and normalizes the Operators.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; A = ALFA.gallery.Laplace(N=1)
Lattice Basis: ALFA.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], [1.0])
 ALFA.Multiplier{1}([0], [-2.0])
 ALFA.Multiplier{1}([1], [1.0])

julia&gt; B = ALFA.gallery.fw_restriction(N=1)
Lattice Basis: ALFA.Lattice{1,Float64}([2.0])
Domain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 2-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], Rational{Int64}[0//1 1//2])
 ALFA.Multiplier{1}([0], Rational{Int64}[1//1 1//2])

julia&gt; (A2,B2) = ALFA.wrtSameLatticeAndNormalize(A,B);

julia&gt; A2
Lattice Basis: ALFA.Lattice{1,Float64}([2.0])
Domain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Codomain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Multiplier: 3-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], [0.0 1.0; 0.0 0.0])
 ALFA.Multiplier{1}([0], [-2.0 1.0; 1.0 -2.0])
 ALFA.Multiplier{1}([1], [0.0 0.0; 1.0 0.0])

julia&gt; B2
Lattice Basis: ALFA.Lattice{1,Float64}([2.0])
Domain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 2-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], Rational{Int64}[0//1 1//2])
 ALFA.Multiplier{1}([0], Rational{Int64}[1//1 1//2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL609-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.CrystalOperator{N,T},ALFA.CrystalOperator{N,T}}} where T where N" href="#Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.CrystalOperator{N,T},ALFA.CrystalOperator{N,T}}} where T where N"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(A::CrystalOperator{N,T}, B::CrystalOperator{N,T}) where {N,T}</code></pre><p>If there is a least common multiple translationally invariance of A and B, then both operators A and B are rewritten wrt this translationally invariance A2 and B2. After that, it is checked if domain and codomain are compatible. If thats the case, the crystaloperator A2\cdot B2 is constructed.</p><p class="math-container">\[A2\cdot B2 : \mathcal{L}(B2.C.L^\text{Domain}) \rightarrow \mathcal{L}(A2.C.L^\text{Codomain})\]</p><p>with</p><p class="math-container">\[(A2\cdot B2\cdot f)(x) = \sum_{a \in A2.M, b \in B2.M} a.\text{mat}\cdot b.\text{mat} ⋅ f(x+a.\text{pos}+b.\text{pos}) \quad \forall x \in (A2.C.L.A)\mathbb{Z}^N.\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; A = ALFA.gallery.Laplace(N=1)
Lattice Basis: ALFA.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], [1.0])
 ALFA.Multiplier{1}([0], [-2.0])
 ALFA.Multiplier{1}([1], [1.0])

julia&gt; R = ALFA.gallery.fw_restriction(N=1)
Lattice Basis: ALFA.Lattice{1,Float64}([2.0])
Domain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 2-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], Rational{Int64}[0//1 1//2])
 ALFA.Multiplier{1}([0], Rational{Int64}[1//1 1//2])

julia&gt; R*A
Lattice Basis: ALFA.Lattice{1,Float64}([2.0])
Domain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], [0.5 0.0])
 ALFA.Multiplier{1}([0], [-1.0 0.0])
 ALFA.Multiplier{1}([1], [0.5 0.0])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL790-L843">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{T,ALFA.CrystalOperator}} where T&lt;:Number" href="#Base.:*-Union{Tuple{T}, Tuple{T,ALFA.CrystalOperator}} where T&lt;:Number"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(b::T, A::CrystalOperator) where {T&lt;:Number}
Base.:*(A::CrystalOperator{N,T}, b::S) where {N,T,S&lt;:Number}</code></pre><p>Constructs a translationally invariant <code>C::CrystalOperators{N,T}</code></p><p class="math-container">\[b\cdot C : \mathcal{L}(C.L^\text{Domain}) \rightarrow \mathcal{L}(C.L^\text{Codomain})\]</p><p>with</p><p class="math-container">\[(b\cdot C\cdot f)(x) = b\cdot \sum_{y \in C.M} y.\text{mat} ⋅ f(x+y.\text{pos}) \quad \forall x \in (C.L.A)\mathbb{Z}^N\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; L = ALFA.gallery.Laplace(N=1)
Lattice Basis: ALFA.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], [1.0])
 ALFA.Multiplier{1}([0], [-2.0])
 ALFA.Multiplier{1}([1], [1.0])

julia&gt; 2L
Lattice Basis: ALFA.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], [2.0])
 ALFA.Multiplier{1}([0], [-4.0])
 ALFA.Multiplier{1}([1], [2.0])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL731-L770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.CrystalOperator{N,T},ALFA.CrystalOperator{N,T}}} where T where N" href="#Base.:+-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.CrystalOperator{N,T},ALFA.CrystalOperator{N,T}}} where T where N"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:+(A::CrystalOperator{N,T}, B::CrystalOperator{N,T}) where {N,T}</code></pre><p>If there is a least common multiple translationally invariance of A and B, then both operators A and B are rewritten wrt this translationally invariance A2 and B2. After that, it is checked if domain and codomain are compatible. If thats the case, the crystaloperator A2+t B2 is constructed.</p><p class="math-container">\[A2+B2 : \mathcal{L}(A2.C.L^\text{Domain}) \rightarrow \mathcal{L}(A2.C.L^\text{Codomain})\]</p><p>with</p><p class="math-container">\[(A2+B2\cdot f)(x) = (A2\cdot f)(x) + (B2\cdot f)(x) \quad \forall x \in (A2.C.L.A)\mathbb{Z}^N.\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; A = ALFA.gallery.Laplace(N=1)
Lattice Basis: ALFA.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], [1.0])
 ALFA.Multiplier{1}([0], [-2.0])
 ALFA.Multiplier{1}([1], [1.0])

julia&gt; A+A
Lattice Basis: ALFA.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], [2.0])
 ALFA.Multiplier{1}([0], [-4.0])
 ALFA.Multiplier{1}([1], [2.0])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL898-L939">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Union{Tuple{T}, Tuple{ALFA.CrystalOperator,T}} where T&lt;:Number" href="#Base.:/-Union{Tuple{T}, Tuple{ALFA.CrystalOperator,T}} where T&lt;:Number"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(A::CrystalOperator, b::T) where {T&lt;:Number}</code></pre><p>Constructs a translationally invariant <code>C::CrystalOperators{N,T}</code></p><p class="math-container">\[C/b : \mathcal{L}(C.L^\text{Domain}) \rightarrow \mathcal{L}(C.L^\text{Codomain})\]</p><p>with</p><p class="math-container">\[(C/b\cdot f)(x) = \frac{1}{b} \sum_{y \in C.M} y.\text{mat} ⋅ f(x+y.\text{pos}) \quad \forall x \in (C.L.A)\mathbb{Z}^N\]</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; L = ALFA.gallery.Laplace(N=1)
Lattice Basis: ALFA.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], [1.0])
 ALFA.Multiplier{1}([0], [-2.0])
 ALFA.Multiplier{1}([1], [1.0])

julia&gt; L/2
Lattice Basis: ALFA.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{1}([-1], [0.5])
 ALFA.Multiplier{1}([0], [-1.0])
 ALFA.Multiplier{1}([1], [0.5])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL688-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{ALFA.Lattice,Vararg{Any,N} where N}" href="#Base.getindex-Tuple{ALFA.Lattice,Vararg{Any,N} where N}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.getindex(L::Lattice, y...)</code></pre><p>simply wrapping getindex(L.A, y...).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; L = ALFA.Lattice{2,Float64}([1 2; 3 4])
ALFA.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])
julia&gt; L[1,2] == L.A[1,2]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/lattice.jl#LL78-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Tuple{ALFA.Lattice,Symbol}" href="#Base.getproperty-Tuple{ALFA.Lattice,Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.getproperty(L::Lattice, sym::Symbol)</code></pre><p>Get properties of Lattice{N,T}. Let <span>$A=$</span>L.A, i.e., <span>$A ∈ T^{N × N}$</span>, then</p><ul><li>L.n and L.dim return the dimension N.</li><li>L.iA returns <span>$A^{-1}$</span>, i.e., the <em>inverse</em> of the lattice basis</li><li>L.dA returns <span>$A^{-T}$</span>, i.e., the basis of the <em>dual</em> lattice.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; L = ALFA.Lattice{2,Float64}([1 2; 3 4])
ALFA.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])
julia&gt; L.n == L.dim == typeof(L).parameters[1] == 2
true
julia&gt; L[2,1]
3.0
julia&gt; L.iA == inv(L.A)
true
julia&gt; L.dA == transpose(inv(L.A))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/lattice.jl#LL95-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.lcm-Union{Tuple{T}, Tuple{X}, Tuple{StaticArrays.MArray{X,T,N,L} where L where N,StaticArrays.MArray{X,T,N,L} where L where N}} where T&lt;:Real where X" href="#Base.lcm-Union{Tuple{T}, Tuple{X}, Tuple{StaticArrays.MArray{X,T,N,L} where L where N,StaticArrays.MArray{X,T,N,L} where L where N}} where T&lt;:Real where X"><code>Base.lcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.lcm(A::MArray{X,T},B::MArray{X,T}...)
Base.lcm(A::MArray{X,T}, B::MArray{X,T}...) where {X,T&lt;:Rational}

Base.lcm(A::Lattice{N,T}, B::Lattice{N,T}...) where {N,T}
Base.lcm(A::MArray{X,T}, B::MArray{X,T}...) where {X,T&lt;:Rational}</code></pre><p>Returns the least common multiple of <span>$A$</span> and <span>$B$</span> (or more), i.e. a sub-lattice <span>$C$</span>, that is <span>$C ⊂ A$</span> and <span>$C ⊂ B$</span> with <span>$|\det(C)|$</span> as small as possible.</p><p>See Algorithm B.7, Theorem 5.1 in [1].</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; L = ALFA.Lattice{2,Float64}([1 2; 3 4])
ALFA.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])

julia&gt; ALFA.lcm(L) == L
true

julia&gt; ALFA.lcm(L.A) == L.A
true

julia&gt; ALFA.lcm(ALFA.Lattice{1,Float64}([2]), ALFA.Lattice{1,Float64}([3]), ALFA.Lattice{1,Float64}([6]))
ALFA.Lattice{1,Float64}([6.0])

julia&gt; ALFA.lcm(ALFA.Lattice{2,Rational{BigInt}}([1 1; -1 1]), ALFA.Lattice{2,Rational{BigInt}}([1 2; 2 1]))
ALFA.Lattice{2,Rational{BigInt}}(Rational{BigInt}[-3//1 1//1; -3//1 -1//1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/lattice.jl#LL133-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.push!(S::CrystalOperator, m::Multiplier, add_to_existing = false)</code></pre><p>Adds a multiplier to S.M. If there is a multiplier m2 in S.M with m2.pos == m.pos, then</p><ul><li>m2 is replaced if <code>add_to_existing</code> == false</li><li>m2.mat+m.mat is the new multiplier at m.pos if <code>add_to_existing</code> == true.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; S = ALFA.gallery.Laplace()
Lattice Basis: ALFA.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 5-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{2}([-1, 0], [1.0])
 ALFA.Multiplier{2}([0, -1], [1.0])
 ALFA.Multiplier{2}([0, 0], [-4.0])
 ALFA.Multiplier{2}([0, 1], [1.0])
 ALFA.Multiplier{2}([1, 0], [1.0])

julia&gt; m = ALFA.Multiplier{2}([0, 0], [1])
Position: 2-element StaticArrays.MArray{Tuple{2},Int64,1,2} with indices SOneTo(2):
 0
 0
Multiplier: 1×1 Array{Int64,2}:
 1

julia&gt; push!(S,m)
Lattice Basis: ALFA.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 5-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{2}([-1, 0], [1.0])
 ALFA.Multiplier{2}([0, -1], [1.0])
 ALFA.Multiplier{2}([0, 0], [1])
 ALFA.Multiplier{2}([0, 1], [1.0])
 ALFA.Multiplier{2}([1, 0], [1.0])

julia&gt; push!(S,m, true)
Lattice Basis: ALFA.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 5-element Array{ALFA.Multiplier,1}:
 ALFA.Multiplier{2}([-1, 0], [1.0])
 ALFA.Multiplier{2}([0, -1], [1.0])
 ALFA.Multiplier{2}([0, 0], [2])
 ALFA.Multiplier{2}([0, 1], [1.0])
 ALFA.Multiplier{2}([1, 0], [1.0])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/crystaloperator.jl#LL220-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{ALFA.Lattice}" href="#Base.size-Tuple{ALFA.Lattice}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.size(L::Lattice)</code></pre><p>Returns the dimension of the lattice basis: size(L.A,1).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using ALFA

julia&gt; L = ALFA.Lattice{2,Float64}([1 2; 3 4])
ALFA.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])
julia&gt; size(L) == size(L.A) == (2,2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/ALFA.jl/blob/12e613bc894f0d295d0d03d3640e87066f2402b8/src/lattice.jl#LL61-L75">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gallery/">« Gallery</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 2 May 2021 11:59">Sunday 2 May 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
