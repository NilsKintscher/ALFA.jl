<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · alfa.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">alfa.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/example_01/">Tutorial / Example 1.</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../gallery/">Gallery</a></li><li class="is-active"><a class="tocitem" href>Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NilsKintscher/alfa.jl/blob/master/docs/src/internals/internals.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals-1"><a class="docs-heading-anchor" href="#Internals-1">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-1" title="Permalink"></a></h1><ul><li><a href="#alfa.Crystal-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}, Tuple{Any,Any}, Tuple{Any,Any,Any}} where T&lt;:Union{Float64, Rational} where N"><code>alfa.Crystal</code></a></li><li><a href="#alfa.CrystalOperator-Union{Tuple{T}, Tuple{N}, Tuple{alfa.Crystal{N,T},LinearAlgebra.UniformScaling}, Tuple{alfa.Crystal{N,T},LinearAlgebra.UniformScaling,Any}} where T where N"><code>alfa.CrystalOperator</code></a></li><li><a href="#alfa.Lattice-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}} where T&lt;:Union{Float64, Rational} where N"><code>alfa.Lattice</code></a></li><li><a href="#alfa.Multiplier-Union{Tuple{}, Tuple{Any}, Tuple{N}, Tuple{Any,Any}} where N"><code>alfa.Multiplier</code></a></li><li><a href="#alfa.OperatorComposition-Tuple{Expr}"><code>alfa.OperatorComposition</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{T,alfa.CrystalOperator}} where T&lt;:Number"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{alfa.CrystalOperator{N,T},alfa.CrystalOperator{N,T}}} where T where N"><code>Base.:*</code></a></li><li><a href="#Base.:+-Union{Tuple{T}, Tuple{N}, Tuple{alfa.CrystalOperator{N,T},alfa.CrystalOperator{N,T}}} where T where N"><code>Base.:+</code></a></li><li><a href="#Base.:/-Union{Tuple{T}, Tuple{alfa.CrystalOperator,T}} where T&lt;:Number"><code>Base.:/</code></a></li><li><a href="#Base.getindex-Tuple{alfa.Lattice,Vararg{Any,N} where N}"><code>Base.getindex</code></a></li><li><a href="#Base.getproperty-Tuple{alfa.Lattice,Symbol}"><code>Base.getproperty</code></a></li><li><a href="#Base.lcm-Union{Tuple{T}, Tuple{X}, Tuple{StaticArrays.MArray{X,T,N,L} where L where N,StaticArrays.MArray{X,T,N,L} where L where N}} where T&lt;:Real where X"><code>Base.lcm</code></a></li><li><a href="#Base.push!"><code>Base.push!</code></a></li><li><a href="#Base.size-Tuple{alfa.Lattice}"><code>Base.size</code></a></li><li><a href="#alfa.CheckIfNormal-Tuple{Any,Any}"><code>alfa.CheckIfNormal</code></a></li><li><a href="#alfa.CleanUp!-Tuple{alfa.CrystalOperator}"><code>alfa.CleanUp!</code></a></li><li><a href="#alfa.CrystalOperatorCopyLowerTriangle-Union{Tuple{alfa.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>alfa.CrystalOperatorCopyLowerTriangle</code></a></li><li><a href="#alfa.CrystalOperatorCopyWithMultipliers-Union{Tuple{alfa.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>alfa.CrystalOperatorCopyWithMultipliers</code></a></li><li><a href="#alfa.ElementsInQuotientSpace-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L},Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N"><code>alfa.ElementsInQuotientSpace</code></a></li><li><a href="#alfa.ShiftIntoStandardCell-Union{Tuple{T}, Tuple{N}, Tuple{Any,Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N"><code>alfa.ShiftIntoStandardCell</code></a></li><li><a href="#alfa.eigen-Union{Tuple{X}, Tuple{X,Any}} where X&lt;:Union{alfa.OperatorComposition, alfa.CrystalOperator}"><code>alfa.eigen</code></a></li><li><a href="#alfa.eigvals-Union{Tuple{X}, Tuple{T}, Tuple{X,T}} where X&lt;:Union{alfa.OperatorComposition, alfa.CrystalOperator} where T&lt;:Union{Tuple, AbstractArray{T,1} where T}"><code>alfa.eigvals</code></a></li><li><a href="#alfa.eigvals-Union{Tuple{X}, Tuple{X}} where X&lt;:Union{alfa.OperatorComposition, alfa.CrystalOperator}"><code>alfa.eigvals</code></a></li><li><a href="#alfa.eigvals_df-Union{Tuple{X}, Tuple{X}} where X&lt;:Union{alfa.OperatorComposition, alfa.CrystalOperator}"><code>alfa.eigvals_df</code></a></li><li><a href="#alfa.find_multiplier-Tuple{alfa.CrystalOperator,Any}"><code>alfa.find_multiplier</code></a></li><li><a href="#alfa.hnf-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M"><code>alfa.hnf</code></a></li><li><a href="#alfa.lll-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M"><code>alfa.lll</code></a></li><li><a href="#alfa.normalize-Union{Tuple{alfa.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>alfa.normalize</code></a></li><li><a href="#alfa.normalize-Union{Tuple{alfa.Crystal{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>alfa.normalize</code></a></li><li><a href="#alfa.snf_with_transform-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M"><code>alfa.snf_with_transform</code></a></li><li><a href="#alfa.symbol-Tuple{alfa.CrystalOperator,Any}"><code>alfa.symbol</code></a></li><li><a href="#alfa.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{alfa.Crystal{N,T},Any}} where T where N"><code>alfa.wrtLattice</code></a></li><li><a href="#alfa.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{alfa.CrystalOperator{N,T},Any}, Tuple{alfa.CrystalOperator{N,T},Any,Any}, Tuple{alfa.CrystalOperator{N,T},Any,Any,Any}} where T where N"><code>alfa.wrtLattice</code></a></li><li><a href="#alfa.wrtSameLatticeAndNormalize-Tuple{alfa.CrystalOperator,alfa.CrystalOperator}"><code>alfa.wrtSameLatticeAndNormalize</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="alfa.Crystal-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}, Tuple{Any,Any}, Tuple{Any,Any,Any}} where T&lt;:Union{Float64, Rational} where N" href="#alfa.Crystal-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}, Tuple{Any,Any}, Tuple{Any,Any,Any}} where T&lt;:Union{Float64, Rational} where N"><code>alfa.Crystal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Crystal{N,T}(L = nothing, Domain = nothing, Codomain = nothing) where {N,T&lt;:Union{Float64, Rational}}</code></pre><p>Constructs a <code>Crystal{N,T}</code> which respresents the domain and codomain of a CrystalOperator. It consists of a L::Lattice{N,T} and the structure elements Domain::Vector{SVector{N,T}} and Codomain::Vector{SVector{N,T}}.</p><p>This struct describes the set</p><div>\[Aℤ^N+s = \left\{ ∑_{i=0}^n z_j ⋅ a_j + (s_1,s_2,\ldots,s_m)  : z_j ∈ ℤ  \right\},\]</div><p>where <span>$s=(s_1,s_2,\ldots,s_m) ∈ \{\text{Domain,Codomain}\}$</span> is the <em>structure element</em>, <span>$A$</span> the lattice basis L.A.</p><ul><li>In case of L==nothing, the identity I of size N is used.</li><li>In case of Domain==nothing, the origin <span>$0 \in \mathbb{R}^N$</span> is used.</li><li>In case Codomain==nothing, Domain is used.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; alfa.Crystal{2,Float64}()
Lattice Basis: alfa.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystal.jl#LL17-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.CrystalOperator-Union{Tuple{T}, Tuple{N}, Tuple{alfa.Crystal{N,T},LinearAlgebra.UniformScaling}, Tuple{alfa.Crystal{N,T},LinearAlgebra.UniformScaling,Any}} where T where N" href="#alfa.CrystalOperator-Union{Tuple{T}, Tuple{N}, Tuple{alfa.Crystal{N,T},LinearAlgebra.UniformScaling}, Tuple{alfa.Crystal{N,T},LinearAlgebra.UniformScaling,Any}} where T where N"><code>alfa.CrystalOperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CrystalOperator(
    C::Crystal{N,T},
    J::UniformScaling,
    _CompatibilityCheckOnly = false,
) where {N,T}
CrystalOperator{N,T}(
    C = nothing,
    M = nothing,
    _CompatibilityCheckOnly = false,
) where {N,T&lt;:Union{Float64,Rational}}</code></pre><p>Constructs a translationally invariant <code>C::CrystalOperators{N,T}</code></p><div>\[C : \mathcal{L}(C.L^\text{Domain}) \rightarrow \mathcal{L}(C.L^\text{Codomain})\]</div><p>The actual function definition <span>$(Cf)(x)$</span> is saved within <code>C.M::SortedSet{Multiplier}</code>:</p><div>\[(Cf)(x) = \sum_{y \in C.M} y.\text{mat} ⋅ f(x+y.\text{pos}) \quad \forall x \in (C.L.A)\mathbb{Z}^N\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; using LinearAlgebra

julia&gt; alfa.CrystalOperator{2,Float64}()
Lattice Basis: alfa.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 0-element Array{alfa.Multiplier,1}

julia&gt; alfa.CrystalOperator(alfa.Crystal{2,Float64}(),3*I)
Lattice Basis: alfa.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 1-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{2}([0, 0], [3])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystaloperator.jl#LL16-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.Lattice-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}} where T&lt;:Union{Float64, Rational} where N" href="#alfa.Lattice-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}} where T&lt;:Union{Float64, Rational} where N"><code>alfa.Lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Lattice{N,T}(A=nothing)</code></pre><p>Construct a <code>Lattice{N,T}</code> with basis <span>$A$</span>, i.e., it represents the set</p><div>\[Aℤ^N = \left\{ ∑_{i=0}^n z_j ⋅ a_j  : z_j ∈ ℤ \right\},\]</div><p>where <span>$a_j$</span> denotes the <span>$j$</span>th column of <span>$A$</span>. The matrix <span>$A$</span> must be square and nonsingular:</p><ul><li><span>$A$</span> is called the <em>lattice basis</em>.</li><li><span>$a_j$</span> are the <em>primite vectors</em> of the lattice.</li></ul><p><code>T&lt;:Union{Float64,Rational}</code> represents the datatype of the entries of the basis <span>$a_{ij}$</span>.</p><p>In case of A==nothing, the identity I of size N is used.</p><p>See Definition 2.1 in [1].</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.Lattice{3,Float64}()
alfa.Lattice{3,Float64}([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])

julia&gt; L = alfa.Lattice{2,Rational{BigInt}}()
alfa.Lattice{2,Rational{BigInt}}(Rational{BigInt}[1//1 0//1; 0//1 1//1])

julia&gt; L = alfa.Lattice{2,Rational{BigInt}}([1 2; 3 4])
alfa.Lattice{2,Rational{BigInt}}(Rational{BigInt}[1//1 2//1; 3//1 4//1])

julia&gt; L = alfa.Lattice{2,Rational{BigInt}}([1 2; 1 2])
ERROR: AssertionError: Basis must be nonsingular</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/lattice.jl#LL13-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.Multiplier-Union{Tuple{}, Tuple{Any}, Tuple{N}, Tuple{Any,Any}} where N" href="#alfa.Multiplier-Union{Tuple{}, Tuple{Any}, Tuple{N}, Tuple{Any,Any}} where N"><code>alfa.Multiplier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Multiplier{N}(pos = nothing, mat = nothing) where {N}
Multiplier(pos = nothing, mat = nothing)</code></pre><p>Constructs a multiplication matrix as part of a CrystalOperator. The position is given in fractional coordinates and thus (converted to) integral.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; alfa.Multiplier([0 0], [1 2 3; 4 5 6])
Position: 2-element StaticArrays.MArray{Tuple{2},Int64,1,2} with indices SOneTo(2):
 0
 0
Multiplier: 2×3 Array{Int64,2}:
 1  2  3
 4  5  6
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/multiplier.jl#LL12-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.OperatorComposition-Tuple{Expr}" href="#alfa.OperatorComposition-Tuple{Expr}"><code>alfa.OperatorComposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperatorComposition(f::Expr)</code></pre><p>Constructs a struct OperatorComposition from an expression. All CrystalOperators     are rewritten with respect to a single translationally invariance and normalized.     Furthermore, it is checked if the expression is well-defined.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.gallery.Laplace(N=1);

julia&gt; f = :(inv($L)*$L);

julia&gt; oc = alfa.OperatorComposition(f);

julia&gt; alfa.symbol(oc,[randn(1)]) ≈ [1] # as f is the identitity, the fourier transform is 1 for all frequencies.
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/operatorcomposition.jl#LL9-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{alfa.CrystalOperator{N,T},alfa.CrystalOperator{N,T}}} where T where N" href="#Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{alfa.CrystalOperator{N,T},alfa.CrystalOperator{N,T}}} where T where N"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(A::CrystalOperator{N,T}, B::CrystalOperator{N,T}) where {N,T}</code></pre><p>If there is a least common multiple translationally invariance of A and B, then both operators A and B are rewritten wrt this translationally invariance A2 and B2. After that, it is checked if domain and codomain are compatible. If thats the case, the crystaloperator A2\cdot B2 is constructed.</p><div>\[A2\cdot B2 : \mathcal{L}(B2.C.L^\text{Domain}) \rightarrow \mathcal{L}(A2.C.L^\text{Codomain})\]</div><p>with</p><div>\[(A2\cdot B2\cdot f)(x) = \sum_{a \in A2.M, b \in B2.M} a.\text{mat}\cdot b.\text{mat} ⋅ f(x+a.\text{pos}+b.\text{pos}) \quad \forall x \in (A2.C.L.A)\mathbb{Z}^N.\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; A = alfa.gallery.Laplace(N=1)
Lattice Basis: alfa.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], [1.0])
 alfa.Multiplier{1}([0], [-2.0])
 alfa.Multiplier{1}([1], [1.0])

julia&gt; R = alfa.gallery.fw_restriction(N=1)
Lattice Basis: alfa.Lattice{1,Float64}([2.0])
Domain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 2-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], Rational{Int64}[0//1 1//2])
 alfa.Multiplier{1}([0], Rational{Int64}[1//1 1//2])

julia&gt; R*A
Lattice Basis: alfa.Lattice{1,Float64}([2.0])
Domain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], [0.5 0.0])
 alfa.Multiplier{1}([0], [-1.0 0.0])
 alfa.Multiplier{1}([1], [0.5 0.0])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystaloperator.jl#LL749-L802">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{T,alfa.CrystalOperator}} where T&lt;:Number" href="#Base.:*-Union{Tuple{T}, Tuple{T,alfa.CrystalOperator}} where T&lt;:Number"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(b::T, A::CrystalOperator) where {T&lt;:Number}
Base.:*(A::CrystalOperator{N,T}, b::S) where {N,T,S&lt;:Number}</code></pre><p>Constructs a translationally invariant <code>C::CrystalOperators{N,T}</code></p><div>\[b\cdot C : \mathcal{L}(C.L^\text{Domain}) \rightarrow \mathcal{L}(C.L^\text{Codomain})\]</div><p>with</p><div>\[(b\cdot C\cdot f)(x) = b\cdot \sum_{y \in C.M} y.\text{mat} ⋅ f(x+y.\text{pos}) \quad \forall x \in (C.L.A)\mathbb{Z}^N\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.gallery.Laplace(N=1)
Lattice Basis: alfa.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], [1.0])
 alfa.Multiplier{1}([0], [-2.0])
 alfa.Multiplier{1}([1], [1.0])

julia&gt; 2L
Lattice Basis: alfa.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], [2.0])
 alfa.Multiplier{1}([0], [-4.0])
 alfa.Multiplier{1}([1], [2.0])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystaloperator.jl#LL690-L729">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Union{Tuple{T}, Tuple{N}, Tuple{alfa.CrystalOperator{N,T},alfa.CrystalOperator{N,T}}} where T where N" href="#Base.:+-Union{Tuple{T}, Tuple{N}, Tuple{alfa.CrystalOperator{N,T},alfa.CrystalOperator{N,T}}} where T where N"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:+(A::CrystalOperator{N,T}, B::CrystalOperator{N,T}) where {N,T}</code></pre><p>If there is a least common multiple translationally invariance of A and B, then both operators A and B are rewritten wrt this translationally invariance A2 and B2. After that, it is checked if domain and codomain are compatible. If thats the case, the crystaloperator A2+t B2 is constructed.</p><div>\[A2+B2 : \mathcal{L}(A2.C.L^\text{Domain}) \rightarrow \mathcal{L}(A2.C.L^\text{Codomain})\]</div><p>with</p><div>\[(A2+B2\cdot f)(x) = (A2\cdot f)(x) + (B2\cdot f)(x) \quad \forall x \in (A2.C.L.A)\mathbb{Z}^N.\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; A = alfa.gallery.Laplace(N=1)
Lattice Basis: alfa.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], [1.0])
 alfa.Multiplier{1}([0], [-2.0])
 alfa.Multiplier{1}([1], [1.0])

julia&gt; A+A
Lattice Basis: alfa.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], [2.0])
 alfa.Multiplier{1}([0], [-4.0])
 alfa.Multiplier{1}([1], [2.0])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystaloperator.jl#LL857-L898">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Union{Tuple{T}, Tuple{alfa.CrystalOperator,T}} where T&lt;:Number" href="#Base.:/-Union{Tuple{T}, Tuple{alfa.CrystalOperator,T}} where T&lt;:Number"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(A::CrystalOperator, b::T) where {T&lt;:Number}</code></pre><p>Constructs a translationally invariant <code>C::CrystalOperators{N,T}</code></p><div>\[C/b : \mathcal{L}(C.L^\text{Domain}) \rightarrow \mathcal{L}(C.L^\text{Codomain})\]</div><p>with</p><div>\[(C/b\cdot f)(x) = \frac{1}{b} \sum_{y \in C.M} y.\text{mat} ⋅ f(x+y.\text{pos}) \quad \forall x \in (C.L.A)\mathbb{Z}^N\]</div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.gallery.Laplace(N=1)
Lattice Basis: alfa.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], [1.0])
 alfa.Multiplier{1}([0], [-2.0])
 alfa.Multiplier{1}([1], [1.0])

julia&gt; L/2
Lattice Basis: alfa.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], [0.5])
 alfa.Multiplier{1}([0], [-1.0])
 alfa.Multiplier{1}([1], [0.5])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystaloperator.jl#LL647-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{alfa.Lattice,Vararg{Any,N} where N}" href="#Base.getindex-Tuple{alfa.Lattice,Vararg{Any,N} where N}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.getindex(L::Lattice, y...)</code></pre><p>simply wrapping getindex(L.A, y...).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.Lattice{2,Float64}([1 2; 3 4])
alfa.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])
julia&gt; L[1,2] == L.A[1,2]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/lattice.jl#LL78-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Tuple{alfa.Lattice,Symbol}" href="#Base.getproperty-Tuple{alfa.Lattice,Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.getproperty(L::Lattice, sym::Symbol)</code></pre><p>Get properties of Lattice{N,T}. Let <span>$A=$</span>L.A, i.e., <span>$A ∈ T^{N × N}$</span>, then</p><ul><li>L.n and L.dim return the dimension N.</li><li>L.iA returns <span>$A^{-1}$</span>, i.e., the <em>inverse</em> of the lattice basis</li><li>L.dA returns <span>$A^{-T}$</span>, i.e., the basis of the <em>dual</em> lattice.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.Lattice{2,Float64}([1 2; 3 4])
alfa.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])
julia&gt; L.n == L.dim == typeof(L).parameters[1] == 2
true
julia&gt; L[2,1]
3.0
julia&gt; L.iA == inv(L.A)
true
julia&gt; L.dA == transpose(inv(L.A))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/lattice.jl#LL95-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.lcm-Union{Tuple{T}, Tuple{X}, Tuple{StaticArrays.MArray{X,T,N,L} where L where N,StaticArrays.MArray{X,T,N,L} where L where N}} where T&lt;:Real where X" href="#Base.lcm-Union{Tuple{T}, Tuple{X}, Tuple{StaticArrays.MArray{X,T,N,L} where L where N,StaticArrays.MArray{X,T,N,L} where L where N}} where T&lt;:Real where X"><code>Base.lcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.lcm(A::MArray{X,T},B::MArray{X,T}...)
Base.lcm(A::MArray{X,T}, B::MArray{X,T}...) where {X,T&lt;:Rational}

Base.lcm(A::Lattice{N,T}, B::Lattice{N,T}...) where {N,T}
Base.lcm(A::MArray{X,T}, B::MArray{X,T}...) where {X,T&lt;:Rational}</code></pre><p>Returns the least common multiple of <span>$A$</span> and <span>$B$</span> (or more), i.e. a sub-lattice <span>$C$</span>, that is <span>$C ⊂ A$</span> and <span>$C ⊂ B$</span> with <span>$|\det(C)|$</span> as small as possible.</p><p>See Algorithm B.7, Theorem 5.1 in [1].</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.Lattice{2,Float64}([1 2; 3 4])
alfa.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])

julia&gt; alfa.lcm(L) == L
true

julia&gt; alfa.lcm(L.A) == L.A
true

julia&gt; alfa.lcm(alfa.Lattice{1,Float64}([2]), alfa.Lattice{1,Float64}([3]), alfa.Lattice{1,Float64}([6]))
alfa.Lattice{1,Float64}([6.0])

julia&gt; alfa.lcm(alfa.Lattice{2,Rational{BigInt}}([1 1; -1 1]), alfa.Lattice{2,Rational{BigInt}}([1 2; 2 1]))
alfa.Lattice{2,Rational{BigInt}}(Rational{BigInt}[-3//1 1//1; -3//1 -1//1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/lattice.jl#LL133-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.push!(S::CrystalOperator, m::Multiplier, add_to_existing = false)</code></pre><p>Adds a multiplier to S.M. If there is a multiplier m2 in S.M with m2.pos == m.pos, then</p><ul><li>m2 is replaced if <code>add_to_existing</code> == false</li><li>m2.mat+m.mat is the new multiplier at m.pos if <code>add_to_existing</code> == true.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; S = alfa.gallery.Laplace()
Lattice Basis: alfa.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 5-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{2}([-1, 0], [1.0])
 alfa.Multiplier{2}([0, -1], [1.0])
 alfa.Multiplier{2}([0, 0], [-4.0])
 alfa.Multiplier{2}([0, 1], [1.0])
 alfa.Multiplier{2}([1, 0], [1.0])

julia&gt; m = alfa.Multiplier{2}([0, 0], [1])
Position: 2-element StaticArrays.MArray{Tuple{2},Int64,1,2} with indices SOneTo(2):
 0
 0
Multiplier: 1×1 Array{Int64,2}:
 1

julia&gt; push!(S,m)
Lattice Basis: alfa.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 5-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{2}([-1, 0], [1.0])
 alfa.Multiplier{2}([0, -1], [1.0])
 alfa.Multiplier{2}([0, 0], [1])
 alfa.Multiplier{2}([0, 1], [1.0])
 alfa.Multiplier{2}([1, 0], [1.0])

julia&gt; push!(S,m, true)
Lattice Basis: alfa.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 5-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{2}([-1, 0], [1.0])
 alfa.Multiplier{2}([0, -1], [1.0])
 alfa.Multiplier{2}([0, 0], [2])
 alfa.Multiplier{2}([0, 1], [1.0])
 alfa.Multiplier{2}([1, 0], [1.0])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystaloperator.jl#LL215-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{alfa.Lattice}" href="#Base.size-Tuple{alfa.Lattice}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.size(L::Lattice)</code></pre><p>Returns the dimension of the lattice basis: size(L.A,1).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.Lattice{2,Float64}([1 2; 3 4])
alfa.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])
julia&gt; size(L) == size(L.A) == (2,2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/lattice.jl#LL61-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.CheckIfNormal-Tuple{Any,Any}" href="#alfa.CheckIfNormal-Tuple{Any,Any}"><code>alfa.CheckIfNormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CheckIfNormal(s, A)</code></pre><p>Checks if s is found within the primtive cell of A, i.e., <span>$A^{-1}s_j ∈ [0,1)^N$</span> and if s is sorted lexicographically.</p><p>See Definition 5.4 in [1].</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; using LinearAlgebra

julia&gt; L = alfa.Lattice{2,Float64}([1 0; 0 1]);

julia&gt; s = [[-1/2,0], [1/4,2]]
2-element Array{Array{Float64,1},1}:
 [-0.5, 0.0]
 [0.25, 2.0]

julia&gt;  alfa.CheckIfNormal(s,L)
false

julia&gt; t = [[1/4,0], [1/2,0]]
2-element Array{Array{Float64,1},1}:
 [0.25, 0.0]
 [0.5, 0.0]

julia&gt; alfa.CheckIfNormal(t,L)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/lattice.jl#LL360-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.CleanUp!-Tuple{alfa.CrystalOperator}" href="#alfa.CleanUp!-Tuple{alfa.CrystalOperator}"><code>alfa.CleanUp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CleanUp!(S::CrystalOperator)</code></pre><p>Removes all multipliers m with norm(m.mat) == 0.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; using LinearAlgebra

julia&gt; S = alfa.CrystalOperator(alfa.Crystal{2,Float64}(),0*I)
Lattice Basis: alfa.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 1-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{2}([0, 0], [0])

julia&gt; alfa.CleanUp!(S)

julia&gt; S
Lattice Basis: alfa.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 0-element Array{alfa.Multiplier,1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystaloperator.jl#LL375-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.CrystalOperatorCopyLowerTriangle-Union{Tuple{alfa.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N" href="#alfa.CrystalOperatorCopyLowerTriangle-Union{Tuple{alfa.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>alfa.CrystalOperatorCopyLowerTriangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CrystalOperatorCopyLowerTriangle(S::CrystalOperator{N,T}; idx = nothing, omega=1.0) where {N,T}</code></pre><p>Returns the CrystalOperator G consisting of the central multiplier of S:     m<em>G^{(0)} = p@m</em>L^{(pos)}@p if pos ≦ 0,     m_G^{(y)} = 0 if pos &gt; 0.</p><pre><code class="language-none">with P[i,j] = 1 if i=j in idx,
    = 0 else.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystaloperator.jl#LL176-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.CrystalOperatorCopyWithMultipliers-Union{Tuple{alfa.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N" href="#alfa.CrystalOperatorCopyWithMultipliers-Union{Tuple{alfa.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>alfa.CrystalOperatorCopyWithMultipliers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CrystalOperatorCopyWithMultipliers(S::CrystalOperator{N,T}; pos = nothing, idx = nothing) where {N,T}</code></pre><p>Returns the CrystalOperator G consisting of the central multiplier of S:     m<em>G^{(0)} = p@m</em>L^{(pos)}@p,     m_G^{(y)} = 0 if y != pos,</p><pre><code class="language-none">with P[i,j] = 1 if i=j in idx,
    = 0 else.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystaloperator.jl#LL144-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.ElementsInQuotientSpace-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L},Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N" href="#alfa.ElementsInQuotientSpace-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L},Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N"><code>alfa.ElementsInQuotientSpace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ElementsInQuotientSpace(
    A::Union{Matrix{T},MMatrix{N,N,T}},
    B::Union{Matrix{T},MMatrix{N,N,T}};
    return_diag_hnf::Bool = false,
    return_fractional::Bool = false,
) where {N,T}</code></pre><p>Returns all lattice points of the lattice generated by <span>$A$</span> found in the primitive cell of B, i.e.,</p><div>\[T_{A,B}=\{x : x ∈ A \mathbb{Z}^N \cap B[0,1)^N \}\]</div><p>See Algorithm B.3, Theorem 2.3 in [1].</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; A = alfa.Lattice{2,Float64}([1 0; 0 1]);

julia&gt; B = alfa.Lattice{2,Float64}([2 0; 0 2]);

julia&gt; alfa.ElementsInQuotientSpace(A.A,B.A)
4-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
 [1.0, 0.0]
 [0.0, 1.0]
 [1.0, 1.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/lattice.jl#LL203-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.ShiftIntoStandardCell-Union{Tuple{T}, Tuple{N}, Tuple{Any,Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N" href="#alfa.ShiftIntoStandardCell-Union{Tuple{T}, Tuple{N}, Tuple{Any,Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N"><code>alfa.ShiftIntoStandardCell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ShiftIntoStandardCell(s, A::Union{Matrix{T},MMatrix{N,N,T}}) where {N,T}
ShiftIntoStandardCell(s, A::Union{Matrix{T},MMatrix{N,N,T}}) where {N,T&lt;:Rational}
ShiftIntoStandardCell(s, A::Lattice)</code></pre><p>Shifts all elements s[i] into the primitive cell <span>$A[0,1)^N$</span> and sort the entries lexicographically. The function returns t, y, p, such that</p><div>\[t_j + A y_j = s_{p(j)}\]</div><ul><li>t is the shifted vector s, i.e., <span>$A^{-1}t_j ∈ [0,1)^N$</span> for all j.</li><li>p is the permutation with respect to the input s.</li><li>y corresponds to the shift in fractional coordinates.</li></ul><p>See Definition 2.2, 5.2  in [1].</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; using LinearAlgebra

julia&gt; L = alfa.Lattice{2,Float64}([1 0; 0 1]);

julia&gt; s = [[-1/2,0], [1/4,2]]
2-element Array{Array{Float64,1},1}:
 [-0.5, 0.0]
 [0.25, 2.0]

julia&gt; (t, y, p) = alfa.ShiftIntoStandardCell(s,L);

julia&gt; t
2-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.25, 0.0]
 [0.5, 0.0]

julia&gt; y
2-element Array{StaticArrays.MArray{Tuple{2},Float64,1,2},1}:
 [0.0, 2.0]
 [-1.0, 0.0]

julia&gt; p
2-element Array{Int64,1}:
 2
 1

julia&gt; [t[j] + L.A*y[j] - s[p[j]] for j in [1,2]]
2-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
 [0.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/lattice.jl#LL266-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.eigen-Union{Tuple{X}, Tuple{X,Any}} where X&lt;:Union{alfa.OperatorComposition, alfa.CrystalOperator}" href="#alfa.eigen-Union{Tuple{X}, Tuple{X,Any}} where X&lt;:Union{alfa.OperatorComposition, alfa.CrystalOperator}"><code>alfa.eigen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigen(S::X, k; by = abs) where {X&lt;:Union{CrystalOperator,OperatorComposition}}</code></pre><p>Computes the eigenvalues and eigenvectors of the symbol of a CrystalOperator/OperatorComposition wrt frequency k.</p><p>The eigenvalues are sorted by <code>by</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/analysis.jl#LL109-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.eigvals-Union{Tuple{X}, Tuple{T}, Tuple{X,T}} where X&lt;:Union{alfa.OperatorComposition, alfa.CrystalOperator} where T&lt;:Union{Tuple, AbstractArray{T,1} where T}" href="#alfa.eigvals-Union{Tuple{X}, Tuple{T}, Tuple{X,T}} where X&lt;:Union{alfa.OperatorComposition, alfa.CrystalOperator} where T&lt;:Union{Tuple, AbstractArray{T,1} where T}"><code>alfa.eigvals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigvals(
    S::X,
    k::T;
    by = abs,
) where {
    T&lt;:Union{AbstractVector,Tuple},
    X&lt;:Union{CrystalOperator,OperatorComposition},
}</code></pre><p>Computes the eigenvalues of the symbol of a CrystalOperator/OperatorComposition wrt frequency k.</p><p>The eigenvalues are sorted by <code>by</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/analysis.jl#LL34-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.eigvals-Union{Tuple{X}, Tuple{X}} where X&lt;:Union{alfa.OperatorComposition, alfa.CrystalOperator}" href="#alfa.eigvals-Union{Tuple{X}, Tuple{X}} where X&lt;:Union{alfa.OperatorComposition, alfa.CrystalOperator}"><code>alfa.eigvals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigvals(
    S::X;
    N = 20,
    by = abs,
    unique = false,
    digits = 5,
) where {X&lt;:Union{CrystalOperator,OperatorComposition}}</code></pre><p>Computes the eigenvalues of the symbol of a CrystalOperator/OperatorComposition. The Frequency space is divided into N^dim equidistant (unique) points frequencies k.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/analysis.jl#LL66-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.eigvals_df-Union{Tuple{X}, Tuple{X}} where X&lt;:Union{alfa.OperatorComposition, alfa.CrystalOperator}" href="#alfa.eigvals_df-Union{Tuple{X}, Tuple{X}} where X&lt;:Union{alfa.OperatorComposition, alfa.CrystalOperator}"><code>alfa.eigvals_df</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eigvals_df(S::X; N = 20, by = abs) where {X&lt;:Union{CrystalOperator,OperatorComposition}}</code></pre><p>Returns a dataframe with the eigenvalues of the symbol of a CrystalOperator/OperatorComposition. The Frequency space is divided into N^dim equidistant (unique) points frequencies k.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/analysis.jl#LL123-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.find_multiplier-Tuple{alfa.CrystalOperator,Any}" href="#alfa.find_multiplier-Tuple{alfa.CrystalOperator,Any}"><code>alfa.find_multiplier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_multiplier(S::CrystalOperator, pos)</code></pre><p>Returns the multiplier at pos if existent (in S.M).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; S = alfa.gallery.Laplace()
Lattice Basis: alfa.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Multiplier: 5-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{2}([-1, 0], [1.0])
 alfa.Multiplier{2}([0, -1], [1.0])
 alfa.Multiplier{2}([0, 0], [-4.0])
 alfa.Multiplier{2}([0, 1], [1.0])
 alfa.Multiplier{2}([1, 0], [1.0])

julia&gt; alfa.find_multiplier(S, [0, 0])
Position: 2-element StaticArrays.MArray{Tuple{2},Int64,1,2} with indices SOneTo(2):
 0
 0
Multiplier: 1×1 Array{Float64,2}:
 -4.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystaloperator.jl#LL104-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.hnf-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M" href="#alfa.hnf-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M"><code>alfa.hnf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hnf(mat::MMatrix{M,N}) where {M, N}
hnf(mat::Matrix)</code></pre><p>Wrapper of Nemo.hnf. Input is converted to BigInt. Returns H = mat*U, s.t. H is in Hermite Normal Form and U is unimodular.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa # hide

julia&gt; using LinearAlgebra # hide

julia&gt; mat = rand(1:1000, 2, 2);

julia&gt; H = alfa.hnf(mat);

julia&gt; norm(LinearAlgebra.tril(H) - H) ≈ 0
true
julia&gt; round(abs(det(inv(mat)*H)), digits=5)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/nemo_wrapper.jl#LL67-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.lll-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M" href="#alfa.lll-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M"><code>alfa.lll</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lll(mat::MMatrix{M,N}) where {M, N}
lll(mat::Matrix)</code></pre><p>Wrapper of Nemo.lll. Input is converted to BigInt. Applies the LLL-Algorithm to the input mat. Computes output L, such that mat*T=L for some unimodular T.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa # hide

julia&gt; using LinearAlgebra # hide

julia&gt; mat = rand(1:1000, 2, 2);

julia&gt; L = alfa.lll(mat);

julia&gt; round(abs(det(inv(mat)*L)), digits=5)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/nemo_wrapper.jl#LL106-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.normalize-Union{Tuple{alfa.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N" href="#alfa.normalize-Union{Tuple{alfa.CrystalOperator{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>alfa.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize(S::CrystalOperator{N,T}) where {N,T}</code></pre><p>Normalizes the crystaloperator, i.e., returns an crystaloperator isomorphic to S where all structure elements are shifted in the standard cell <span>$S.C.L.A\cdot[0,1)^N$</span> and sorted lexicographically.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; S = alfa.CrystalOperator{1,Float64}(alfa.Crystal{1,Float64}([1], [-.5], [1.5]))
Lattice Basis: alfa.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [-0.5]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [1.5]
Multiplier: 0-element Array{alfa.Multiplier,1}

julia&gt; push!(S, alfa.Multiplier([0], [-2]))
Lattice Basis: alfa.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [-0.5]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [1.5]
Multiplier: 1-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([0], [-2])

julia&gt; alfa.normalize(S)
Lattice Basis: alfa.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.5]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.5]
Multiplier: 1-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-2], [-2])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystaloperator.jl#LL291-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.normalize-Union{Tuple{alfa.Crystal{N,T}}, Tuple{T}, Tuple{N}} where T where N" href="#alfa.normalize-Union{Tuple{alfa.Crystal{N,T}}, Tuple{T}, Tuple{N}} where T where N"><code>alfa.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize(C::Crystal{N,T}) where {N,T}</code></pre><p>Normalizes the crystal, i.e., shifts the structure elements Domain and Codomain into the standard primitive cell.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; C = alfa.Crystal{1,Float64}([2], [[-1],[-.5],[-1.5]], [[0]])
Lattice Basis: alfa.Lattice{1,Float64}([2.0])
Domain: 3-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [-1.0]
 [-0.5]
 [-1.5]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]

julia&gt; alfa.normalize(C)
Lattice Basis: alfa.Lattice{1,Float64}([2.0])
Domain: 3-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.5]
 [1.0]
 [1.5]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystal.jl#LL102-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.snf_with_transform-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M" href="#alfa.snf_with_transform-Union{Tuple{StaticArrays.MArray{Tuple{M,N},T,2,L} where L where T}, Tuple{N}, Tuple{M}} where N where M"><code>alfa.snf_with_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">snf_with_transform(L::Lattice)
snf_with_transform(mat::MMatrix{M,N}) where {M,N}
snf_with_transform(mat::Matrix)</code></pre><p>Wrapper of Nemo.snf<em>with</em>transform. Input is converted to BigInt. Returns (S,U,V) such that U<em>mat</em>V = S, where S is the Smith normal form of mat.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa # hide

julia&gt; using LinearAlgebra # hide

julia&gt; mat = rand(1:10, 10, 10);

julia&gt; (S,U,V) = alfa.snf_with_transform(mat);

julia&gt; norm(U*mat*V - S) ≈ 0
true

julia&gt; abs(det(U)) ≈ abs(det(V)) ≈ 1
true

julia&gt; norm(diagm(diag(S)) - S) ≈ 0
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/nemo_wrapper.jl#LL19-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.symbol-Tuple{alfa.CrystalOperator,Any}" href="#alfa.symbol-Tuple{alfa.CrystalOperator,Any}"><code>alfa.symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symbol(S::CrystalOperator, k; π = π)
symbol(O::OperatorComposition, k; π = π)</code></pre><p>Returns the symbol of the CrystalOperator/OperatorComposition for a given frequency/wavevector k.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.gallery.Laplace(N=2);

julia&gt; oc = alfa.OperatorComposition(:(3*$L));

julia&gt; alfa.symbol(oc,[0.5, 0.5]) ≈ [-24] # as f is the identitity, the fourier transform is 1 for all frequencies.
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/analysis.jl#LL1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{alfa.CrystalOperator{N,T},Any}, Tuple{alfa.CrystalOperator{N,T},Any,Any}, Tuple{alfa.CrystalOperator{N,T},Any,Any,Any}} where T where N" href="#alfa.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{alfa.CrystalOperator{N,T},Any}, Tuple{alfa.CrystalOperator{N,T},Any,Any}, Tuple{alfa.CrystalOperator{N,T},Any,Any,Any}} where T where N"><code>alfa.wrtLattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wrtLattice(
    S::CrystalOperator{N,T},
    A,
    _CompatibilityCheckOnly = false,
    normalize = true
) where {N,T}</code></pre><p>Rewrites the crystaloperator S wit hrespect to the translationally invariance A.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; L = alfa.gallery.Laplace(N=1)
Lattice Basis: alfa.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], [1.0])
 alfa.Multiplier{1}([0], [-2.0])
 alfa.Multiplier{1}([1], [1.0])

julia&gt; alfa.wrtLattice(L, L.C.L.A*2)
Lattice Basis: alfa.Lattice{1,Float64}([2.0])
Domain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Codomain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Multiplier: 3-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], [0.0 1.0; 0.0 0.0])
 alfa.Multiplier{1}([0], [-2.0 1.0; 1.0 -2.0])
 alfa.Multiplier{1}([1], [0.0 0.0; 1.0 0.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystaloperator.jl#LL414-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{alfa.Crystal{N,T},Any}} where T where N" href="#alfa.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{alfa.Crystal{N,T},Any}} where T where N"><code>alfa.wrtLattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wrtLattice(C::Crystal, L::Lattice)
wrtLattice(C::Crystal{N,T}, A) where {N,T}</code></pre><p>Rewrites the crystal with respect to L::Lattice or lattice basis A. Thus, the lattice must be a sublattice of C.L.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; using LinearAlgebra

julia&gt; C = alfa.Crystal{2,Float64}()
Lattice Basis: alfa.Lattice{2,Float64}([1.0 0.0; 0.0 1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]

julia&gt; L = alfa.Lattice{2,Float64}(2*I)
alfa.Lattice{2,Float64}([2.0 0.0; 0.0 2.0])

julia&gt; alfa.wrtLattice(C,L)
Lattice Basis: alfa.Lattice{2,Float64}([2.0 0.0; 0.0 2.0])
Domain: 4-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
 [1.0, 0.0]
 [0.0, 1.0]
 [1.0, 1.0]
Codomain: 4-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:
 [0.0, 0.0]
 [1.0, 0.0]
 [0.0, 1.0]
 [1.0, 1.0]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystal.jl#LL137-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="alfa.wrtSameLatticeAndNormalize-Tuple{alfa.CrystalOperator,alfa.CrystalOperator}" href="#alfa.wrtSameLatticeAndNormalize-Tuple{alfa.CrystalOperator,alfa.CrystalOperator}"><code>alfa.wrtSameLatticeAndNormalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wrtSameLatticeAndNormalize(A::CrystalOperator, B::CrystalOperator)</code></pre><p>Finds a least common multiple translationally invariance C and rewrites both operators A and B wrt C and normalizes the Operators.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using alfa

julia&gt; A = alfa.gallery.Laplace(N=1)
Lattice Basis: alfa.Lattice{1,Float64}([1.0])
Domain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 3-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], [1.0])
 alfa.Multiplier{1}([0], [-2.0])
 alfa.Multiplier{1}([1], [1.0])

julia&gt; B = alfa.gallery.fw_restriction(N=1)
Lattice Basis: alfa.Lattice{1,Float64}([2.0])
Domain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 2-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], Rational{Int64}[0//1 1//2])
 alfa.Multiplier{1}([0], Rational{Int64}[1//1 1//2])

julia&gt; (A2,B2) = alfa.wrtSameLatticeAndNormalize(A,B);

julia&gt; A2
Lattice Basis: alfa.Lattice{1,Float64}([2.0])
Domain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Codomain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Multiplier: 3-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], [0.0 1.0; 0.0 0.0])
 alfa.Multiplier{1}([0], [-2.0 1.0; 1.0 -2.0])
 alfa.Multiplier{1}([1], [0.0 0.0; 1.0 0.0])

julia&gt; B2
Lattice Basis: alfa.Lattice{1,Float64}([2.0])
Domain: 2-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
 [1.0]
Codomain: 1-element Array{StaticArrays.SArray{Tuple{1},Float64,1,1},1}:
 [0.0]
Multiplier: 2-element Array{alfa.Multiplier,1}:
 alfa.Multiplier{1}([-1], Rational{Int64}[0//1 1//2])
 alfa.Multiplier{1}([0], Rational{Int64}[1//1 1//2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NilsKintscher/alfa.jl/blob/4e780c0405baba20955f74cd2df4e2a42bc6fb15/src/crystaloperator.jl#LL568-L625">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gallery/">« Gallery</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 5 April 2020 08:40">Sunday 5 April 2020</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
