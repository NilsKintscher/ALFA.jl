var documenterSearchIndex = {"docs":
[{"location":"#alfa.jl-1","page":"Home","title":"alfa.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [alfa]","category":"page"},{"location":"#alfa.Lattice-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}} where T<:Union{Float64, Rational} where N","page":"Home","title":"alfa.Lattice","text":"Lattice{N,T}(A=nothing)\n\nConstruct a Lattice{N,T} with basis A, i.e., it represents the set\n\nAℤ^N = left _i=0^n z_j  a_j   z_j  ℤ right\n\nwhere a_j denotes the jth column of A. The matrix A must be square and nonsingular:\n\nA is called the lattice basis.\na_j are the primite vectors of the lattice.\n\nT<:Union{Float64,Rational} represents the datatype of the entries of the basis a_ij.\n\nIn case of A==nothing, the identity I of size N is used.\n\nExample\n\njulia> using alfa\n\njulia> L = alfa.Lattice{3,Float64}()\nalfa.Lattice{3,Float64}([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])\n\njulia> L = alfa.Lattice{2,Rational{BigInt}}()\nalfa.Lattice{2,Rational{BigInt}}(Rational{BigInt}[1//1 0//1; 0//1 1//1])\n\njulia> L = alfa.Lattice{2,Rational{BigInt}}([1 2; 3 4])\nalfa.Lattice{2,Rational{BigInt}}(Rational{BigInt}[1//1 2//1; 3//1 4//1])\n\njulia> L = alfa.Lattice{2,Rational{BigInt}}([1 2; 1 2])\nERROR: AssertionError: Basis must be nonsingular\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{alfa.Lattice,Vararg{Any,N} where N}","page":"Home","title":"Base.getindex","text":"Base.getindex(L::Lattice, y...)\n\nsimply wrapping getindex(L.A, y...).\n\nExample\n\njulia> using alfa\n\njulia> L = alfa.Lattice{2,Float64}([1 2; 3 4])\nalfa.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])\njulia> L[1,2] == L.A[1,2]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Base.getproperty-Tuple{alfa.Lattice,Symbol}","page":"Home","title":"Base.getproperty","text":"Base.getproperty(L::Lattice, sym::Symbol)\n\nGet properties of Lattice{N,T}. Let A=L.A, i.e., A  T^N  N, then\n\nL.n and L.dim return the dimension N.\nL.iA returns A^-1, i.e., the inverse of the lattice basis\nL.dA returns A^-T, i.e., the basis of the dual lattice.\n\nExample\n\njulia> using alfa\n\njulia> L = alfa.Lattice{2,Float64}([1 2; 3 4])\nalfa.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])\njulia> L.n == L.dim == typeof(L).parameters[1] == 2\ntrue\njulia> L[2,1]\n3.0\njulia> L.iA == inv(L.A)\ntrue\njulia> L.dA == transpose(inv(L.A))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Base.lcm-Union{Tuple{T}, Tuple{X}, Tuple{StaticArrays.MArray{X,T,N,L} where L where N,StaticArrays.MArray{X,T,N,L} where L where N}} where T<:Real where X","page":"Home","title":"Base.lcm","text":"Base.lcm(A::MArray{X,T},B::MArray{X,T}...)\nBase.lcm(A::MArray{X,T}, B::MArray{X,T}...) where {X,T<:Rational}\n\nBase.lcm(A::Lattice{N,T}, B::Lattice{N,T}...) where {N,T}\nBase.lcm(A::MArray{X,T}, B::MArray{X,T}...) where {X,T<:Rational}\n\nReturns the least common multiple of A and B (or more), i.e. a sub-lattice C, that is C  A and C  B with det(C) as small as possible.\n\nExample\n\njulia> using alfa\n\njulia> L = alfa.Lattice{2,Float64}([1 2; 3 4])\nalfa.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])\n\njulia> alfa.lcm(L) == L\ntrue\n\njulia> alfa.lcm(L.A) == L.A\ntrue\n\njulia> alfa.lcm(alfa.Lattice{1,Float64}([2]), alfa.Lattice{1,Float64}([3]), alfa.Lattice{1,Float64}([6]))\nalfa.Lattice{1,Float64}([6.0])\n\njulia> alfa.lcm(alfa.Lattice{2,Rational{BigInt}}([1 1; -1 1]), alfa.Lattice{2,Rational{BigInt}}([1 2; 2 1]))\nalfa.Lattice{2,Rational{BigInt}}(Rational{BigInt}[-3//1 1//1; -3//1 -1//1])\n\n\n\n\n\n","category":"method"},{"location":"#Base.size-Tuple{alfa.Lattice}","page":"Home","title":"Base.size","text":"Base.size(L::Lattice)\n\nReturns the dimension of the lattice basis: size(L.A,1).\n\nExample\n\njulia> using alfa\n\njulia> L = alfa.Lattice{2,Float64}([1 2; 3 4])\nalfa.Lattice{2,Float64}([1.0 2.0; 3.0 4.0])\njulia> size(L) == size(L.A) == (2,2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#alfa.CheckIfNormal-Tuple{Any,Any}","page":"Home","title":"alfa.CheckIfNormal","text":"CheckIfNormal(s, A)\n\nChecks if s is found within the primtive cell of A, i.e., `A^{-1}s_j ∈ [0,1)^N and if s is sorted lexicographically.\n\nExample\n\njulia> using alfa\n\njulia> using LinearAlgebra\n\njulia> L = alfa.Lattice{2,Float64}([1 0; 0 1]);\n\njulia> s = [[-1/2,0], [1/4,2]]\n2-element Array{Array{Float64,1},1}:\n [-0.5, 0.0]\n [0.25, 2.0]\n\njulia>  alfa.CheckIfNormal(s,L)\nfalse\n\njulia> t = [[1/4,0], [1/2,0]]\n2-element Array{Array{Float64,1},1}:\n [0.25, 0.0]\n [0.5, 0.0]\n\njulia> alfa.CheckIfNormal(t,L)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#alfa.ElementsInQuotientSpace-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L},Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N","page":"Home","title":"alfa.ElementsInQuotientSpace","text":"ElementsInQuotientSpace(\n    A::Union{Matrix{T},MMatrix{N,N,T}},\n    B::Union{Matrix{T},MMatrix{N,N,T}};\n    return_diag_hnf::Bool = false,\n    return_fractional::Bool = false,\n) where {N,T}\n\nReturns all lattice points of the lattice generated by A found in the primitive cell of B, i.e.,\n\nT_AB=x  x  A mathbbZ^N cap B01)^N \n\nExample\n\njulia> using alfa\n\njulia> A = alfa.Lattice{2,Float64}([1 0; 0 1]);\n\njulia> B = alfa.Lattice{2,Float64}([2 0; 0 2]);\n\njulia> alfa.ElementsInQuotientSpace(A.A,B.A)\n4-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:\n [0.0, 0.0]\n [1.0, 0.0]\n [0.0, 1.0]\n [1.0, 1.0]\n\n\n\n\n\n","category":"method"},{"location":"#alfa.ShiftIntoUnitCell-Union{Tuple{T}, Tuple{N}, Tuple{Any,Union{Array{T,2}, StaticArrays.MArray{Tuple{N,N},T,2,L} where L}}} where T where N","page":"Home","title":"alfa.ShiftIntoUnitCell","text":"ShiftIntoUnitCell(s, A::Union{Matrix{T},MMatrix{N,N,T}}) where {N,T}\nShiftIntoUnitCell(s, A::Union{Matrix{T},MMatrix{N,N,T}}) where {N,T<:Rational}\nShiftIntoUnitCell(s, A::Lattice)\n\nShifts all elements s[i] into the primitive cell A01)^N and sort the entries lexicographically. The function returns t, y, p, such that\n\nt_j + A y_j = s_p(j)\n\ns is the shifted vector s, i.e., A^-1s_j  01)^N for all j.\np is the permutation with respect to the input s.\ny corresponds to the shift in fractional coordinates\n\nExample\n\njulia> using alfa\n\njulia> using LinearAlgebra\n\njulia> L = alfa.Lattice{2,Float64}([1 0; 0 1]);\n\njulia> s = [[-1/2,0], [1/4,2]]\n2-element Array{Array{Float64,1},1}:\n [-0.5, 0.0]\n [0.25, 2.0]\n\njulia> (t, y, p) = alfa.ShiftIntoUnitCell(s,L);\n\njulia> t\n2-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:\n [0.25, 0.0]\n [0.5, 0.0]\n\njulia> y\n2-element Array{StaticArrays.MArray{Tuple{2},Float64,1,2},1}:\n [0.0, 2.0]\n [-1.0, 0.0]\n\njulia> p\n2-element Array{Int64,1}:\n 2\n 1\n\njulia> [t[j] + L.A*y[j] - s[p[j]] for j in [1,2]]\n2-element Array{StaticArrays.SArray{Tuple{2},Float64,1,2},1}:\n [0.0, 0.0]\n [0.0, 0.0]\n\n\n\n\n\n","category":"method"}]
}
