var documenterSearchIndex = {"docs":
[{"location":"examples/example_01/#Example-1:-Tutorial","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"This example should serve as a tutorial of the ALFA framework. We analyze several components of a two-grid method to solve the linear system of equations Ax=b, where A corresponds to the two-dimensional Laplacian discretized on an equidistant rectangular lattice.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"This example is structured as follows.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We define the underyling linear operator: The second order approximation of the two-dimensional Laplacian L obtained via finite central differences (5-point stencil). We further compute its spectrum.\nWe show the connection of the operator L to the system matrix A.\nWe introduce and analyze the Jacobi-method.\nWe define the coarse grid correction.\nWe analyze the two-grid method using the Jacobi-method as a smoother.\nWe introduce the lexicographic Gauss-Seidel and red-black Gauss-Seidel smoother and analyze the corresponding two-grid method.\nWe use this framework to prototype an actual two-grid method.","category":"page"},{"location":"examples/example_01/#Importing-required-packages","page":"Example 1: Tutorial","title":"Importing required packages","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"using ALFA\nusing LinearAlgebra\nusing Plots","category":"page"},{"location":"examples/example_01/#The-discretized-Laplacian-L-in-2D","page":"Example 1: Tutorial","title":"The discretized Laplacian L in 2D","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We are going to define the 2D discretized Laplacian LmathcalL(mathbbL^s(mathcalA)) rightarrow mathcalL(mathbbL^s(mathcalA)) on an equidistant rectangular lattice. Thus, mathbbL^s(mathcalA) describes the underlying structure of the domain and codomain of the operator L.","category":"page"},{"location":"examples/example_01/#Definition-of-the-underlying-lattice-structure","page":"Example 1: Tutorial","title":"Definition of the underlying lattice structure","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"First, we need to define a basis of the underlying translational-invariance: an equidistant rectangular lattice is given by","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"mathcalA = frac1hleftbeginmatrix 1  0  0  1 endmatrixright = leftbeginmatrix mathcala_1  mathcala_2endmatrixright","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"The lattice generated by mathcalA is the set","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"mathbbL(mathcalA) = mathcalAmathbbZ^2 = x = alpha_1mathcala_1 + alpha_2mathcala_2    alpha_1alpha_2 in mathbbZ","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"The class ALFA.Lattice corresponds to mathbbL(mathcalA) and is initialized with the matrix mathcalA.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"h = .1  # define h\nA = h*[1 0; 0 1]  # 2x2 identity matrix scaled with h\n\n# initialize the lattice;\n#In the constructor we need to specify the size/dimensionality (N=2)\n# and the datatype of the lattice basis (T=Float64)\n#  (the alternative to Float is Rational{BigInt})\nLA = ALFA.Lattice{2, Float64}(A)  \n","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We can plot a section of the lattice. Black arrows correspond to the primitive vectors a_1 and a_2","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"plot(LA)","category":"page"},{"location":"examples/example_01/#Definition-of-the-domain-and-codomain-of-the-operator-L","page":"Example 1: Tutorial","title":"Definition of the domain and codomain of the operator L","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"The structure element s of mathbbL^s(mathcalA) corresponds of the location of the unknowns. We can simply choose s=(s_1), where s_1=(00), such that the crystal points coincide with the lattice structure.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"The struct ALFA.Crystal is used to represent both crystals corresponding to the domain and codomain of an operator. We initialize it with ALFA.Crystal{N,T}(LA,s_domain, s_codomain), where sdomain corresponds to the structure element of the domain, and scodomain corresponds to the structure element of the codomain. (In our case we have sdomain = scodomain = s):","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"Domain = [[0,0]]\nCodomain = [[0,0]]\nCA = ALFA.Crystal{2,Float64}(LA,Domain,Codomain)","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We can have a plot function to plot a section of a crystal:","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"plot(CA)","category":"page"},{"location":"examples/example_01/#Initializing-the-operator-L","page":"Example 1: Tutorial","title":"Initializing the operator L","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"As we have defined the underlying domain and codomain of our operator, we can initialize the multiplication operator L.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"This class represents a multiplication operator corresponding to","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"(Lf)(x) = sum_y in mathbbZ^textd   m_L^y cdot f(x+mathcalAy)","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"for all x in mathbbL(mathcalA), where d=2 is the dimensionality. Note, that the position of the operator is given in fractional coordinates, not in cartesian coordinates mathcalAy, such that y is always integral.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"L = ALFA.CrystalOperator{2,Float64}(CA)","category":"page"},{"location":"examples/example_01/#Adding-the-multipliers-of-L","page":"Example 1: Tutorial","title":"Adding the multipliers of L","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We use push!(L,m) to add multipliers m_L^y to the operator in order to define the discretized Laplacian. As the structure elements of the domain and codomain are both 1-dimensional, the matrices m_L^{y} are of size 1times 1.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"The multipliers are then saved within a SortedSet L.m which is lexicographically ordered with respect to the position y.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"push!(L, ALFA.Multiplier([0 0], [-4/h^2]))\npush!(L, ALFA.Multiplier([0 -1], [1/h^2]))\npush!(L, ALFA.Multiplier([0 1], [1/h^2]))\npush!(L, ALFA.Multiplier([1 0], [1/h^2]))\npush!(L, ALFA.Multiplier([-1 0], [1/h^2]))\n\n@show L","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"A schematic representation can be created with the plot command.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"plot(L)","category":"page"},{"location":"examples/example_01/#Computing-the-spectrum-of-L","page":"Example 1: Tutorial","title":"Computing the spectrum of L","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"The spectrum of a CrystalOperator is computed via the ALFAsymbol(LCrystalOperatorkVector) method, where k is the frequency/wavevector.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"ALFA.symbol(L,[0, 0])","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"In order to compute or approximate the \"complete\" spectrum, we divide 01)^textd into N^d equidistant points to get a discretization of the primitive cell of the dual lattice mathcalA^-T01)^textd. Next, we compute the eigenvalues for each symbol(L,k), where k is sampled on these N^d points.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"ALFA.eigvals(L,N=10)","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We may also save everything in a dataframe via ALFA.eigvals_df(L,N=N) or directly produce a plot of the absolut part of the spectrum as follows","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"plotspectrum(L,N=20)","category":"page"},{"location":"examples/example_01/#Obtaining-a-system-matrix-A-from-a-multiplication-operator-L","page":"Example 1: Tutorial","title":"Obtaining a system matrix A from a multiplication operator L","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We can obtain the system matrix A corresponding to the a discretization of the Laplacian on the unit square [0,1]^2 with periodic boundary conditions in two steps.","category":"page"},{"location":"examples/example_01/#Step-1","page":"Example 1: Tutorial","title":"Step 1","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We rewrite L with respect to the sublattice mathbbL(mathcalZ) subset mathbbL(mathcalA) with mathcalZ=left(beginmatrix 1  0  0  1 endmatrixright).","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"Due to the fact that we find 1h^2 = 100 lattice points in Z01)^2 cap mathbbL(mathcalA) = tildes, we obtain an operator","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"tildeAmathcalL(mathbbL^tildes(mathcalZ)) rightarrow mathcalL(mathbbL^tildes(mathcalA)) text with  (tildeA g)(x) =  sum_y in mathbbZ^textd   m_tildeA^y cdot g(x+mathcalZy) quad m_tildeA in mathbbC^100times 100","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"using SparseArrays\ntA = ALFA.wrtLattice(L,ALFA.Lattice{2, Float64}([1 0; 0 1]))\ntA = ALFA.normalize(tA); # make sure all points of the structure elements are within [0,1)^2 and lexicographically ordered.\nnothing # hide","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We create a spy plot of all five multipliers of tA. One multiplier corresponds to the interaction of the unknowns within the unit cell. The other four multipliers correspond to the connections beyond the boundaries:","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"using SparseArrays\nparr = []\nfor x in tA.M\n    p = spy(SparseMatrixCSC(x.mat), c=:blues, title=\"position: \" * string(x.pos))\n    push!(parr, p)\nend\nplot(parr...);","category":"page"},{"location":"examples/example_01/#Step-two","page":"Example 1: Tutorial","title":"Step two","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"As we impose periodic boundary conditions on the unit square, all lattice points of mathbbL(Z) are identified. Thus, we obtain the system matrix A by adding all multipliers of tA.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"tAm = sum(x.mat for x in tA.M);\nspy(SparseMatrixCSC(tAm), c=:blues);","category":"page"},{"location":"examples/example_01/#A-link-between-the-the-eigenvalues-of-A-and-L_k","page":"Example 1: Tutorial","title":"A link between the the eigenvalues of A and L_k","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We can compute the eigenvalues and eigenvectors of A and compare them with the eigenvalues computed via LFA:","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"eig1 = abs.(sort(eigvals(tAm), by=abs))\neig2 = abs.(ALFA.eigvals(L,N=10, by=abs))\n\np = plot(eig1, label=\"eigenvalues of the system matrix\")\nplot!(eig2, label=\"eigenvalues computed via the symbol\")\nplot!(abs.(eig1.-eig2), label=\"pairwise difference of the eigenvalues.\")\n","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"The eigenvalues are equal as long as N=1/h, where h corresponds to the lattice spacing and N corresponds to the discretization of the frequency space.","category":"page"},{"location":"examples/example_01/#Analysis-of-stationary-iterative-methods","page":"Example 1: Tutorial","title":"Analysis of stationary iterative methods","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"Given a linear system of equations (LSE) Ax=b, the Jacobi method produces iterates via","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"x_k+1 leftarrow (I-S^-1A)x_k + S^-1b","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"where I is the identity and S is simply the diagonal of A.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"Denote with x^* = A^-1b the solution of the LSE and with e_k = x^* - x_k the kth error. Since","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"e_k+1 = (I-S^-1A)e_k","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"the operator G=(I-S^-1A) is called error propagator. We are interested in the spectral radius rho(G)=maxlambda      lambda text Eigenvalue of G   of the error propagator, as we have","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"e_k+1 approx rho(G) e_k","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"for large k (if the initial error has a component in the direction of the eigenvector corresponding to the largest absolute eigenvalue).","category":"page"},{"location":"examples/example_01/#The-Jacobi-method","page":"Example 1: Tutorial","title":"The Jacobi method","text":"","category":"section"},{"location":"examples/example_01/#Definition-of-the-Jacobi-method","page":"Example 1: Tutorial","title":"Definition of the Jacobi-method","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We compute the spectrum via LFA, thus we need to define I and S as multiplication operators. In case of the Jacobi method, the multipliers of","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"SmathcalL(mathbbL^s(mathcalA)) rightarrow mathcalL(mathbbL^s(mathcalA)) quadquad quad (Sf)(x) = sum_y in mathbbZ^textd   m_S^y cdot f(x+mathcalAy)","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"are given by","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"m_S^y = begincases m_L^y   text if  y = 0  0  text else endcases","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"S_jac = ALFA.CrystalOperatorCopyWithMultipliers(L)\n\nplot(S_jac)","category":"page"},{"location":"examples/example_01/#Analysis-of-the-Jacobi-method","page":"Example 1: Tutorial","title":"Analysis of the Jacobi-method","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We analyze the error propagator of the Jacobi method using underrelaxation of .8.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"f_jac =:(I-0.8*inv($S_jac)*$L) # construct an expression holding the CrystalOperators S and L.\noc = ALFA.OperatorComposition(f_jac)\n\nplotspectrum(oc, 40) # plot the absolute part of the spectrum using 40^2 points.","category":"page"},{"location":"examples/example_01/#Definition-of-the-two-grid-error-propagator","page":"Example 1: Tutorial","title":"Definition of the two-grid error propagator","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We are going to analyze the two-grid method corresponding to the error propagator KG_1 = (I-P L_c^-1 RL)cdot G_1 with R=P^T, L_c = RLP. Thus, we only have to define the prolongation operator P explicitly. This operator maps from a coarse crystal to the fine crystal mathbbL^s(mathcalA).","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We use the following coarse grid: mathbbL^t(2mathcalA), t=(00):","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"plot(ALFA.Lattice{2, Float64}(2*L.C.A))","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"The so-called 'full weighting' prolongation operator P has a translational invariance of 2mathcalA. Thus we can define it within this framework as P  mathcalL(mathbbL^t(2mathcalA)) rightarrow mathcalL(mathbbL^hats(2mathcalA))","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"where the codomain mathbbL^hats(2mathcalA) is a representation of the fine crystal mathbbL^s(mathcalA), but with respect to the larger translational invariance. This is the case if the structure element consists of all lattice points mathbbL(mathcalA) found in the primitive cell 2mathcalA01)^2:  hats = mathbbL^s(mathcalA) cap 2mathcalA01)^2 =  ( s s + mathcala_1 s + mathcala_2 s + mathcala_1 + mathcala_2) = ( 0  mathcala_1  mathcala_2  mathcala_1 + mathcala_2)","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"p_domain = [[0, 0]]  # corresponds to \"t\" in the above description\n# corresponds to \\hat{s} in the above description\np_codomain = [A*[0, 0], A*[0, 1], A*[1, 0], A*[1, 1]]\n\n\nCcoarse = ALFA.Crystal{2,Float64}(2*L.C.A, p_domain, p_codomain)\n\n# a plot of the domain and codomain.\nplot(Ccoarse)","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We initialize and define the prolongation operator P. This operator maps a value of each coarse grid point to its 9 nearest fine-grid points:","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"P = ALFA.CrystalOperator{2,Float64}(Ccoarse)\npush!(P, ALFA.Multiplier([0,0], [1; 1/2; 1/2; 1/4]))\npush!(P, ALFA.Multiplier([1,0], [0;   0; 1/2; 1/4]))\npush!(P, ALFA.Multiplier([0,1], [0; 1/2;   0; 1/4]))\npush!(P, ALFA.Multiplier([1,1], [0;   0;   0; 1/4]))\n\nplot(P)","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We can compute the restriction operator R=P^T and the coarse grid operator L_c = RLP.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"R = transpose(P)\nLc = R*L*P\nplot(plot(R), plot(Lc))","category":"page"},{"location":"examples/example_01/#Two-grid-analysis-with-Jacobi-smoothing:","page":"Example 1: Tutorial","title":"Two-grid analysis with Jacobi smoothing:","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"As all operators share the translational invariance of mathbbL(2mathcalA) each operator can be rewritten with respect to this translational invariance. Alltogether, the error propagator is a mapping","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"KG_1  mathcalL(mathbbL^hats(2mathcalA)) rightarrow mathcalL(mathbbL^hats(2mathcalA))","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"As the structure element is of size 4 ( hats = ( 0  mathcala_1  mathcala_2  mathcala_1 + mathcala_2)), its symbol (KG_1)_k is of size 4times 4 and we obtain 4 eigenvalues per wavevector k.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"f_cgc = :(I-$P*inv($Lc)*$R*$L)\nf_tgj = f_cgc*f_jac\noc_tgj = ALFA.OperatorComposition(f_tgj)\nALFA.symbol(oc_tgj, [0,0])","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"A plot of the absolute part of the spectrum:","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"plotspectrum(oc_tgj, N=20, zfilter=(0,0.7))","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"Note, that the zfilter filters the eigenvalue corresponding to the constant eigenfunction  (k=(00)) which is in the kernel of L.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"The spectral radius of the two-grid error propagator is 6 when we use underrelaxation of omega = 8 in the Jacobi-method. Thus, the norm of an error is reduced by 40 in each iteration of the two-grid method.","category":"page"},{"location":"examples/example_01/#Lexicographic-Gauss-Seidel-smoothing","page":"Example 1: Tutorial","title":"Lexicographic Gauss-Seidel smoothing","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"Given a linear system of equations (LSE) Ax=b, the Gauss-Seidel method produces iterates via","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"x_k+1 leftarrow (I-S^-1A)x_k + S^-1b","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"where I is the identity and S is simply the triangle of A. We assume that the unknowns x_1x_2ldotsx_1h^2 are ordered lexicographically, i.e.,","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"x_i=(x_i_1 x_i_2)  x_j=(x_j_1 x_j_2) text iff  left(x_i_1  x_j_1) text or  (x_i_1 = x_j_1 text and x_i_2  x_j_2)right","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"In the lower triangle of A we find the connections of each unknown x_i, which is not part of the boundary, to the unknowns x_j with x_i leq x_j. Thus, we can express this operator for all unknowns that do not lie at the boundary. We have  SmathcalL(mathbbL^s(mathcalA)) rightarrow mathcalL(mathbbL^s(mathcalA))","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"(Sf)(x) = sum_y in mathbbZ^textd m_S^y cdot f(x+mathcalAy) quad text for all  x text which do not lie nearat the boundary","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"with nonzero multipliers","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"m_S^y = begincases m_L^y   text if  y leq 0  0  text else endcases","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"where y leq 0 refers to the lexicographic ordering.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"S = ALFA.CrystalOperatorCopyLowerTriangle(L)\n\nplot(S)","category":"page"},{"location":"examples/example_01/#Two-grid-analysis-with-lexicographic-Gauss-Seidel-smoothing:","page":"Example 1: Tutorial","title":"Two-grid analysis with lexicographic Gauss-Seidel smoothing:","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"f_gs = :(I-$inv($S)*$L)\nf_tggs = f_cgc*f_gs\noc_tggs = ALFA.OperatorComposition(f_tggs)\nplotspectrum(oc_tggs, N=40, zfilter=(0,0.7))","category":"page"},{"location":"examples/example_01/#A-colored-smoother:-red-black-Gauss-Seidel","page":"Example 1: Tutorial","title":"A colored smoother: red-black Gauss-Seidel","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"Instead of lexicographic Gauss-Seidel, we can update unknowns using a different ordering. Consider the following red-black coloring of the underlying structure:","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"(Image: title)","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"Red-black Gauss-Seidel corresponds to the method which updates red unknowns before it updates black unknowns. This can be described with an error propagator of the form G_b cdot G_r where G_x=(I - R_x^T (R_x A R_x^T)^-1R_x A), where R_x, x=rb, is the canonical restriction to the red/black unknowns.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"First, we describe the red-black crystal: We have","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"mathbbL^u(C) C = left(beginmatrix mathcala_1 + mathcala_2  mathcala_1 - mathcala_2 endmatrixright) = mathcalAleft(beginmatrix 1  1  1  -1endmatrixright)","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"with u=(0mathcala_1)=(u_textred  u_textblack).","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"C = A*[1 1; 1 -1]\nu = [A*[0,0], A*[1,0]]\nu_red = [u[1]]\nu_black = [u[2]]\nCr = ALFA.Crystal{2,Float64}(C, u, u_red)\nCb = ALFA.Crystal{2,Float64}(C, u, u_black)\n\np1 = plot(Cr)\np2 = plot(Cb)\nplot(p1, p2)","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"Definition of the restriction operators:","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"\nRr = ALFA.CrystalOperator{2,Float64}(Cr)\npush!(Rr, ALFA.Multiplier([0 0], [1 0]))\nRb = ALFA.CrystalOperator{2,Float64}(Cb)\npush!(Rb, ALFA.Multiplier([0 0], [0 1]))\n\np1 = plot(Rr)\np2 = plot(Rb)\nplot(p1, p2)","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"Defintion of the smoother:","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"\nSr = Rr*L*Rr'\nSb = Rb*L*Rb'\n\np1 = plot(Sr)\np2 = plot(Sb)\nplot(p1, p2)","category":"page"},{"location":"examples/example_01/#Twogrid-analysis-with-red-black-smoothing","page":"Example 1: Tutorial","title":"Twogrid analysis with red-black smoothing","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"fr = :(I-$Rr'*$inv($Sr)*$Rr*$L)\nfb = :(I-$Rb'*$inv($Sb)*$Rb*$L)\nf_tgrb = f_cgc*fb*fr\noc_tgrb = ALFA.OperatorComposition(f_tgrb)\nplotspectrum(oc_tgrb, N=40, zfilter=(0,0.7))","category":"page"},{"location":"examples/example_01/#Alternative-construction-and-analysis-of-red-black","page":"Example 1: Tutorial","title":"Alternative construction and analysis of red-black","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"A simpler construction can be done as follows. Note, that we (have to) use the pseudoinverse instead of the inverse as the constructed operators Sr and Sb are singular:","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"Lrb = ALFA.wrtLattice(L, L.C.L.A*[1 1; 1 -1])\nSr = ALFA.CrystalOperatorCopyWithMultipliers(Lrb, idx=[1])\nSb = ALFA.CrystalOperatorCopyWithMultipliers(Lrb, idx=[2])\nfr = :(I-pinv($Sr)*$L)\nfb = :(I-pinv($Sb)*$L)\nf_tgrb = f_cgc*fb*fr\noc_tgrb = ALFA.OperatorComposition(f_tgrb)\nplotspectrum(oc_tgrb, N=40, zfilter=(0,0.7))","category":"page"},{"location":"examples/example_01/#Prototyping-a-two-grid-method","page":"Example 1: Tutorial","title":"Prototyping a two-grid method","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"By rewriting all operators with respect to a shared large translationally invariance mathcalZ analogously to \"Obtaining a system matrix A from a multiplication operator L\", we can prototype a two-grid method as follows. We stick to the Jacobi example.","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"wrtL = ALFA.Lattice{2, Float64}([1 0; 0 1])\nLm = SparseMatrixCSC(ALFA.construct_matrix(L,wrtL))\nRm = SparseMatrixCSC(ALFA.construct_matrix(R,wrtL))\nPm = SparseMatrixCSC(ALFA.construct_matrix(P,wrtL))\nSm = SparseMatrixCSC(ALFA.construct_matrix(S_jac,wrtL))\nLcm = SparseMatrixCSC(ALFA.construct_matrix(Lc,wrtL))\n\nnothing # hide","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"We create a spy plot of all matrices:","category":"page"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"pLm = spy(Lm, c=:blues, title=\"Lm\");\npRm = spy(Rm, c=:blues, title=\"Rm\");\npPm = spy(Pm, c=:blues, title=\"Pm\");\npSm = spy(Sm, c=:blues, title=\"Sm\");\npLcm = spy(Lcm, c=:blues, title=\"Lcm\");\nplot(pLm, pRm, pPm, pSm, pLcm);","category":"page"},{"location":"examples/example_01/#Definition-of-the-application-of-the-smoother-and-coarse-grid-correction","page":"Example 1: Tutorial","title":"Definition of the application of the smoother and coarse grid correction","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"SmLU = lu(Sm)\nLcmLU = lu(Lcm)\n\nfunction smooth(b, x)\n    r = b-Lm*x\n    x += 0.8*(SmLU\\r)\n    return x\nend\n\nfunction cgc(b, x)\n    r = b-Lm*x\n    rc = Rm*r\n    xc = LcmLU\\rc\n    x += Pm*xc\n    return x\nend\nnothing # hide","category":"page"},{"location":"examples/example_01/#Testrun-of-the-twogrid-method.","page":"Example 1: Tutorial","title":"Testrun of  the twogrid method.","text":"","category":"section"},{"location":"examples/example_01/","page":"Example 1: Tutorial","title":"Example 1: Tutorial","text":"\n# initialize rhs and initial guess\nglobal x, b, casym_vec, resnorm_vec, num_iter\nn = size(Lm,1);\nx = zeros(n);\nb = Lm*rand(n);\nb = b/norm(b);\n\ncasym_vec = [1.0]\nresnorm_vec = [1.0]\n\nnum_iter = 0\n\nwhile resnorm_vec[end] > 1e-13 && num_iter < 150\n    global x, b, casym_vec, resnorm_vec, num_iter\n    num_iter = num_iter + 1\n    x = smooth(b,x)\n    x = cgc(b,x)\n    push!(resnorm_vec, norm(b - Lm*x))\n    push!(casym_vec, resnorm_vec[end]/resnorm_vec[end-1])\nend\n\n# plot convergence behavior.\nplot(resnorm_vec, yaxis=:log, xlabel=\"iteration\", ylabel=\"residual norm\", title=\"measured asymptotic convrate=\"*string(casym_vec[end])*\"\\n conv.rate from analysis: \"*string(abs(ALFA.eigvals(oc_tgj,N=20)[end-1])) )\n","category":"page"},{"location":"internals/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"internals/internals/","page":"Internals","title":"Internals","text":"Modules = [ALFA]","category":"page"},{"location":"internals/internals/#ALFA.Crystal-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}, Tuple{Any, Any}, Tuple{Any, Any, Any}} where {N, T<:Union{Float64, Rational}}","page":"Internals","title":"ALFA.Crystal","text":"Crystal{N,T}(L = nothing, Domain = nothing, Codomain = nothing) where {N,T<:Union{Float64, Rational}}\n\nConstructs a Crystal{N,T} which respresents the domain and codomain of a CrystalOperator. It consists of a L::Lattice{N,T} and the structure elements Domain::Vector{SVector{N,T}} and Codomain::Vector{SVector{N,T}}.\n\nThis struct describes the set\n\nAℤ^N+s = left _i=0^n z_j  a_j + (s_1s_2ldotss_m)   z_j  ℤ  right\n\nwhere s=(s_1s_2ldotss_m)  textDomainCodomain is the structure element, A the lattice basis L.A.\n\nIn case of L==nothing, the identity I of size N is used.\nIn case of Domain==nothing, the origin 0 in mathbbR^N is used.\nIn case Codomain==nothing, Domain is used.\n\nExample\n\njulia> using ALFA\n\njulia> ALFA.Crystal{2,Float64}()\nLattice Basis: ALFA.Lattice{2, Float64}([1.0 0.0; 0.0 1.0])\nDomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.CrystalOperator-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.Crystal{N, T}, LinearAlgebra.UniformScaling}, Tuple{ALFA.Crystal{N, T}, LinearAlgebra.UniformScaling, Any}} where {N, T}","page":"Internals","title":"ALFA.CrystalOperator","text":"CrystalOperator(\n    C::Crystal{N,T},\n    J::UniformScaling,\n    _CompatibilityCheckOnly = false,\n) where {N,T}\nCrystalOperator{N,T}(\n    C = nothing,\n    M = nothing,\n    _CompatibilityCheckOnly = false,\n) where {N,T<:Union{Float64,Rational}}\n\nConstructs a translationally invariant C::CrystalOperators{N,T}\n\nC  mathcalL(CL^textDomain) rightarrow mathcalL(CL^textCodomain)\n\nThe actual function definition (Cf)(x) is saved within C.M::SortedSet{Multiplier}:\n\n(Cf)(x) = sum_y in CM ytextmat  f(x+ytextpos) quad forall x in (CLA)mathbbZ^N\n\nExample\n\njulia> using ALFA\n\njulia> using LinearAlgebra\n\njulia> ALFA.CrystalOperator{2,Float64}()\nLattice Basis: ALFA.Lattice{2, Float64}([1.0 0.0; 0.0 1.0])\nDomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nMultiplier: ALFA.Multiplier[]\n\njulia> ALFA.CrystalOperator(ALFA.Crystal{2,Float64}(),3*I)\nLattice Basis: ALFA.Lattice{2, Float64}([1.0 0.0; 0.0 1.0])\nDomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nMultiplier: 1-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{2}([0, 0], [3;;])\n\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.Lattice-Union{Tuple{}, Tuple{Any}, Tuple{T}, Tuple{N}} where {N, T<:Union{Float64, Rational}}","page":"Internals","title":"ALFA.Lattice","text":"Lattice{N,T}(A=nothing)\n\nConstruct a Lattice{N,T} with basis A, i.e., it represents the set\n\nAℤ^N = left _i=0^n z_j  a_j   z_j  ℤ right\n\nwhere a_j denotes the jth column of A. The matrix A must be square and nonsingular:\n\nA is called the lattice basis.\na_j are the primite vectors of the lattice.\n\nT<:Union{Float64,Rational} represents the datatype of the entries of the basis a_ij.\n\nIn case of A==nothing, the identity I of size N is used.\n\nSee Definition 2.1 in [1].\n\nExample\n\njulia> using ALFA\n\njulia> L = ALFA.Lattice{3,Float64}()\nALFA.Lattice{3, Float64}([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])\n\njulia> L = ALFA.Lattice{2,Rational{BigInt}}()\nALFA.Lattice{2, Rational{BigInt}}(Rational{BigInt}[1//1 0//1; 0//1 1//1])\n\njulia> L = ALFA.Lattice{2,Rational{BigInt}}([1 2; 3 4])\nALFA.Lattice{2, Rational{BigInt}}(Rational{BigInt}[1//1 2//1; 3//1 4//1])\n\njulia> L = ALFA.Lattice{2,Rational{BigInt}}([1 2; 1 2])\nERROR: AssertionError: Basis must be nonsingular\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.Multiplier-Union{Tuple{}, Tuple{Any}, Tuple{N}, Tuple{Any, Any}} where N","page":"Internals","title":"ALFA.Multiplier","text":"Multiplier{N}(pos = nothing, mat = nothing) where {N}\nMultiplier(pos = nothing, mat = nothing)\n\nConstructs a multiplication matrix as part of a CrystalOperator. The position is given in fractional coordinates and thus (converted to) integral.\n\nExample\n\njulia> using ALFA\n\njulia> ALFA.Multiplier([0 0], [1 2 3; 4 5 6])\nPosition: 2-element StaticArraysCore.MVector{2, Int64} with indices SOneTo(2):\n 0\n 0\nMultiplier: 2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.OperatorComposition-Tuple{Expr}","page":"Internals","title":"ALFA.OperatorComposition","text":"OperatorComposition(f::Expr)\n\nConstructs a struct OperatorComposition from an expression. All CrystalOperators     are rewritten with respect to a single translationally invariance and normalized.     Furthermore, it is checked if the expression is well-defined.\n\nExample\n\njulia> using ALFA\n\njulia> L = ALFA.gallery.Laplace(N=1);\n\njulia> f = :(inv($L)*$L);\n\njulia> oc = ALFA.OperatorComposition(f);\n\njulia> ALFA.symbol(oc,[randn(1)]) ≈ [1] # as f is the identitity, the fourier transform is 1 for all frequencies.\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.CheckIfNormal-Tuple{Any, Any}","page":"Internals","title":"ALFA.CheckIfNormal","text":"CheckIfNormal(s, A)\n\nChecks if s is found within the primtive cell of A, i.e., A^-1s_j  01)^N and if s is sorted lexicographically.\n\nSee Definition 5.4 in [1].\n\nExample\n\njulia> using ALFA\n\njulia> using LinearAlgebra\n\njulia> L = ALFA.Lattice{2, Float64}([1 0; 0 1]);\n\njulia> s = [[-1/2,0], [1/4,2]]\n2-element Vector{Vector{Float64}}:\n [-0.5, 0.0]\n [0.25, 2.0]\n\njulia>  ALFA.CheckIfNormal(s,L)\nfalse\n\njulia> t = [[1/4,0], [1/2,0]]\n2-element Vector{Vector{Float64}}:\n [0.25, 0.0]\n [0.5, 0.0]\n\njulia> ALFA.CheckIfNormal(t,L)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.CleanUp!-Tuple{ALFA.CrystalOperator}","page":"Internals","title":"ALFA.CleanUp!","text":"CleanUp!(S::CrystalOperator)\n\nRemoves all multipliers m with norm(m.mat) == 0.\n\nExample\n\njulia> using ALFA\n\njulia> using LinearAlgebra\n\njulia> S = ALFA.CrystalOperator(ALFA.Crystal{2,Float64}(),0*I)\nLattice Basis: ALFA.Lattice{2, Float64}([1.0 0.0; 0.0 1.0])\nDomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nMultiplier: 1-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{2}([0, 0], [0;;])\n\njulia> ALFA.CleanUp!(S)\n\njulia> S\nLattice Basis: ALFA.Lattice{2, Float64}([1.0 0.0; 0.0 1.0])\nDomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nMultiplier: ALFA.Multiplier[]\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.CrystalOperatorCopyLowerTriangle-Union{Tuple{ALFA.CrystalOperator{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Internals","title":"ALFA.CrystalOperatorCopyLowerTriangle","text":"CrystalOperatorCopyLowerTriangle(S::CrystalOperator{N,T}; idx = nothing, omega=1.0) where {N,T}\n\nReturns the CrystalOperator G consisting of the central multiplier of S:     mG^{(0)} = p@mL^{(pos)}@p if pos ≦ 0,     m_G^{(y)} = 0 if pos > 0.\n\nwith P[i,j] = 1 if i=j in idx,\n    = 0 else.\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.CrystalOperatorCopyWithMultipliers-Union{Tuple{ALFA.CrystalOperator{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Internals","title":"ALFA.CrystalOperatorCopyWithMultipliers","text":"CrystalOperatorCopyWithMultipliers(S::CrystalOperator{N,T}; pos = nothing, idx = nothing) where {N,T}\n\nReturns the CrystalOperator G consisting of the central multiplier of S:     mG^{(0)} = p@mL^{(pos)}@p,     m_G^{(y)} = 0 if y != pos,\n\nwith P[i,j] = 1 if i=j in idx,\n    = 0 else.\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.ElementsInQuotientSpace-Union{Tuple{T}, Tuple{N}, Tuple{Union{Matrix{T}, StaticArraysCore.MMatrix{N, N, T}}, Union{Matrix{T}, StaticArraysCore.MMatrix{N, N, T}}}} where {N, T}","page":"Internals","title":"ALFA.ElementsInQuotientSpace","text":"ElementsInQuotientSpace(\n    A::Union{Matrix{T},MMatrix{N,N,T}},\n    B::Union{Matrix{T},MMatrix{N,N,T}};\n    return_diag_hnf::Bool = false,\n    return_fractional::Bool = false,\n) where {N,T}\n\nReturns all lattice points of the lattice generated by A found in the primitive cell of B, i.e.,\n\nT_AB=x  x  A mathbbZ^N cap B01)^N \n\nSee Algorithm B.3, Theorem 2.3 in [1].\n\nExample\n\njulia> using ALFA\n\njulia> A = ALFA.Lattice{2, Float64}([1 0; 0 1]);\n\njulia> B = ALFA.Lattice{2, Float64}([2 0; 0 2]);\n\njulia> ALFA.ElementsInQuotientSpace(A.A,B.A)\n4-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\n [1.0, 0.0]\n [0.0, 1.0]\n [1.0, 1.0]\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.ShiftIntoStandardCell-Union{Tuple{T}, Tuple{N}, Tuple{Any, Union{Matrix{T}, StaticArraysCore.MMatrix{N, N, T}}}} where {N, T}","page":"Internals","title":"ALFA.ShiftIntoStandardCell","text":"ShiftIntoStandardCell(s, A::Union{Matrix{T},MMatrix{N,N,T}}) where {N,T}\nShiftIntoStandardCell(s, A::Union{Matrix{T},MMatrix{N,N,T}}) where {N,T<:Rational}\nShiftIntoStandardCell(s, A::Lattice)\n\nShifts all elements s[i] into the primitive cell A01)^N and sort the entries lexicographically. The function returns t, y, p, such that\n\nt_j + A y_j = s_p(j)\n\nt is the shifted vector s, i.e., A^-1t_j  01)^N for all j.\np is the permutation with respect to the input s.\ny corresponds to the shift in fractional coordinates.\n\nSee Definition 2.2, 5.2  in [1].\n\nExample\n\njulia> using ALFA\n\njulia> using LinearAlgebra\n\njulia> L = ALFA.Lattice{2, Float64}([1 0; 0 1]);\n\njulia> s = [[-1/2,0], [1/4,2]]\n2-element Vector{Vector{Float64}}:\n [-0.5, 0.0]\n [0.25, 2.0]\n\njulia> (t, y, p) = ALFA.ShiftIntoStandardCell(s,L);\n\njulia> t\n2-element Vector{StaticArraysCore.MVector{2, Float64}}:\n [0.25, 0.0]\n [0.5, 0.0]\n\njulia> y\n2-element Vector{StaticArraysCore.MVector{2, Float64}}:\n [0.0, 2.0]\n [-1.0, 0.0]\n\njulia> p\n2-element Vector{Int64}:\n 2\n 1\n\njulia> [t[j] + L.A*y[j] - s[p[j]] for j in [1,2]]\n2-element Vector{StaticArraysCore.MVector{2, Float64}}:\n [0.0, 0.0]\n [0.0, 0.0]\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.construct_matrix-Tuple{ALFA.CrystalOperator, ALFA.Lattice}","page":"Internals","title":"ALFA.construct_matrix","text":"construct_matrix(x::ALFA.CrystalOperator,wrt::ALFA.Lattice)\n\nConstructs a matrix from a CrystalOperator with respect to a given Lattice.\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.eigen-Union{Tuple{X}, Tuple{X, Any}} where X<:Union{ALFA.OperatorComposition, ALFA.CrystalOperator}","page":"Internals","title":"ALFA.eigen","text":"eigen(S::X, k; by = abs) where {X<:Union{CrystalOperator,OperatorComposition}}\n\nComputes the eigenvalues and eigenvectors of the symbol of a CrystalOperator/OperatorComposition wrt frequency k.\n\nThe eigenvalues are sorted by by.\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.eigvals-Tuple{X} where X<:Union{ALFA.OperatorComposition, ALFA.CrystalOperator}","page":"Internals","title":"ALFA.eigvals","text":"eigvals(\n    S::X;\n    N = 20,\n    by = abs,\n    unique = false,\n    digits = 5,\n) where {X<:Union{CrystalOperator,OperatorComposition}}\n\nComputes the eigenvalues of the symbol of a CrystalOperator/OperatorComposition. The Frequency space is divided into N^dim equidistant (unique) points frequencies k.\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.eigvals-Union{Tuple{X}, Tuple{T}, Tuple{X, T}} where {T<:Union{Tuple, AbstractVector}, X<:Union{ALFA.OperatorComposition, ALFA.CrystalOperator}}","page":"Internals","title":"ALFA.eigvals","text":"eigvals(\n    S::X,\n    k::T;\n    by = abs,\n) where {\n    T<:Union{AbstractVector,Tuple},\n    X<:Union{CrystalOperator,OperatorComposition},\n}\n\nComputes the eigenvalues of the symbol of a CrystalOperator/OperatorComposition wrt frequency k.\n\nThe eigenvalues are sorted by by.\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.eigvals_df-Tuple{X} where X<:Union{ALFA.OperatorComposition, ALFA.CrystalOperator}","page":"Internals","title":"ALFA.eigvals_df","text":"eigvals_df(S::X; N = 20, by = abs) where {X<:Union{CrystalOperator,OperatorComposition}}\n\nReturns a dataframe with the eigenvalues of the symbol of a CrystalOperator/OperatorComposition. The Frequency space is divided into N^dim equidistant (unique) points frequencies k.\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.find_multiplier-Tuple{ALFA.CrystalOperator, Any}","page":"Internals","title":"ALFA.find_multiplier","text":"find_multiplier(S::CrystalOperator, pos)\n\nReturns the multiplier at pos if existent (in S.M).\n\nExample\n\njulia> using ALFA\n\njulia> S = ALFA.gallery.Laplace()\nLattice Basis: ALFA.Lattice{2, Float64}([1.0 0.0; 0.0 1.0])\nDomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nMultiplier: 5-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{2}([-1, 0], [1.0;;])\n ALFA.Multiplier{2}([0, -1], [1.0;;])\n ALFA.Multiplier{2}([0, 0], [-4.0;;])\n ALFA.Multiplier{2}([0, 1], [1.0;;])\n ALFA.Multiplier{2}([1, 0], [1.0;;])\n\njulia> ALFA.find_multiplier(S, [0, 0])\nPosition: 2-element StaticArraysCore.MVector{2, Int64} with indices SOneTo(2):\n 0\n 0\nMultiplier: 1×1 Matrix{Float64}:\n -4.0\n\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.hnf-Union{Tuple{StaticArraysCore.MMatrix{M, N}}, Tuple{N}, Tuple{M}} where {M, N}","page":"Internals","title":"ALFA.hnf","text":"hnf(mat::MMatrix{M,N}) where {M, N}\nhnf(mat::Matrix)\n\nWrapper of Nemo.hnf. Input is converted to BigInt. Returns H = mat*U, s.t. H is in Hermite Normal Form and U is unimodular.\n\nExample\n\njulia> using ALFA # hide\n\njulia> using LinearAlgebra # hide\n\njulia> mat = rand(1:1000, 2, 2);\n\njulia> H = ALFA.hnf(mat);\n\njulia> norm(LinearAlgebra.tril(H) - H) ≈ 0\ntrue\njulia> round(abs(det(inv(mat)*H)), digits=5)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.lll-Union{Tuple{StaticArraysCore.MMatrix{M, N}}, Tuple{N}, Tuple{M}} where {M, N}","page":"Internals","title":"ALFA.lll","text":"lll(mat::MMatrix{M,N}) where {M, N}\nlll(mat::Matrix)\n\nWrapper of Nemo.lll. Input is converted to BigInt. Applies the LLL-Algorithm to the input mat. Computes output L, such that mat*T=L for some unimodular T.\n\nExample\n\njulia> using ALFA # hide\n\njulia> using LinearAlgebra # hide\n\njulia> mat = rand(1:1000, 2, 2);\n\njulia> L = ALFA.lll(mat);\n\njulia> round(abs(det(inv(mat)*L)), digits=5)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.normalize-Union{Tuple{ALFA.CrystalOperator{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Internals","title":"ALFA.normalize","text":"normalize(S::CrystalOperator{N,T}) where {N,T}\n\nNormalizes the crystaloperator, i.e., returns an crystaloperator isomorphic to S where all structure elements are shifted in the standard cell SCLAcdot01)^N and sorted lexicographically.\n\nExample\n\njulia> using ALFA\n\njulia> S = ALFA.CrystalOperator{1,Float64}(ALFA.Crystal{1,Float64}([1], [-.5], [1.5]))\nLattice Basis: ALFA.Lattice{1, Float64}([1.0;;])\nDomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [-0.5]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [1.5]\nMultiplier: ALFA.Multiplier[]\n\njulia> push!(S, ALFA.Multiplier([0], [-2]))\nLattice Basis: ALFA.Lattice{1, Float64}([1.0;;])\nDomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [-0.5]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [1.5]\nMultiplier: 1-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([0], [-2;;])\n\njulia> ALFA.normalize(S)\nLattice Basis: ALFA.Lattice{1, Float64}([1.0;;])\nDomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.5]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.5]\nMultiplier: 1-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-2], [-2;;])\n\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.normalize-Union{Tuple{ALFA.Crystal{N, T}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Internals","title":"ALFA.normalize","text":"normalize(C::Crystal{N,T}) where {N,T}\n\nNormalizes the crystal, i.e., shifts the structure elements Domain and Codomain into the standard primitive cell.\n\nExample\n\njulia> using ALFA\n\njulia> C = ALFA.Crystal{1,Float64}([2], [[-1],[-.5],[-1.5]], [[0]])\nLattice Basis: ALFA.Lattice{1, Float64}([2.0;;])\nDomain: 3-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [-1.0]\n [-0.5]\n [-1.5]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\n\njulia> ALFA.normalize(C)\nLattice Basis: ALFA.Lattice{1, Float64}([2.0;;])\nDomain: 3-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.5]\n [1.0]\n [1.5]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\n\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.plotspectrum","page":"Internals","title":"ALFA.plotspectrum","text":"plotspectrum(L, N = 20, zfilter = nothing, modifier = abs, surfaceIndexFirst = lastindex, surfaceIndexSecond = lastindex )\n\nPlots the spectrum of L along its dual lattice with N points in each direction.\n\nImplemented only for 1d and 2d.\n\nFor each dual lattice point you may have multiple complex eigenvalues. In order to plot them, you need to modify them by taking for example the absolute part of the eigenvalues. Furthermore, if you have multiple eigenvalues per dual lattice point, you are able to control what surfaces you want to plot via the arguuments surfaceIndexFirst and surfaceIndexSecond.\n\nYou can use zfilter in order to show only the part of the plot between zfilter[1] and zfilter[2]\n\nExample\n\n```jldoctest julia> using ALFA julia> using Plots\n\njulia> L = ALFA.gallery.graphenetightbinding() Lattice Basis: ALFA.Lattice{2, Float64}([1.5 1.5; 0.8660254037844386 -0.8660254037844386]) Domain: 2-element Vector{StaticArraysCore.SVector{2, Float64}}:  [1.0, 0.0]  [2.0, 0.0] Codomain: 2-element Vector{StaticArraysCore.SVector{2, Float64}}:  [1.0, 0.0]  [2.0, 0.0] Multiplier: 9-element Vector{ALFA.Multiplier}:  ALFA.Multiplier{2}([-1, -1], [0 0; 0 0])  ALFA.Multiplier{2}([-1, 0], [0 -1; 0 0])  ALFA.Multiplier{2}([-1, 1], [0 0; 0 0])  ALFA.Multiplier{2}([0, -1], [0 -1; 0 0])  ALFA.Multiplier{2}([0, 0], [0 -1; -1 0])  ALFA.Multiplier{2}([0, 1], [0 0; -1 0])  ALFA.Multiplier{2}([1, -1], [0 0; 0 0])  ALFA.Multiplier{2}([1, 0], [0 0; -1 0])  ALFA.Multiplier{2}([1, 1], [0 0; 0 0])\n\nwe have two eigenvalues per dual lattice point.\n\njulia> plotspectrum(L) # plots the absolute part of the largest absolute eigenvalue\n\njulia> plotspectrum(L, modifier=real, surfaceIndexFirst=firstindex, surfaceIndexSecond=lastindex) # plots the real part of all eigenvalues julia> plotspectrum(L, modifier=real, surfaceIndexFirst=1, surfaceIndexSecond=2) # equivalent to the functioncall above\n\njulia> plotspectrum(L, modifier=real, surfaceIndexFirst=firstindex, surfaceIndexSecond=firstindex) # plots the real part of the smallest eigenvalues\n\njulia> plotspectrum(L, zfilter=[2, 3], modifier=abs, surfaceIndexFirst=lastindex, surfaceIndexSecond=lastindex) # plots the abs part of largest eigenvalues that lie between 2 and 3.\n\njulia> plotspectrum(L, zfilter=[-1,1], modifier=imag, surfaceIndexFirst=1, surfaceIndexSecond=2, zlim=[-1,1]) # modifying z axis of the plot is also possible.\n\n\n\n\n\n","category":"function"},{"location":"internals/internals/#ALFA.snf_with_transform-Union{Tuple{StaticArraysCore.MMatrix{M, N}}, Tuple{N}, Tuple{M}} where {M, N}","page":"Internals","title":"ALFA.snf_with_transform","text":"snf_with_transform(L::Lattice)\nsnf_with_transform(mat::MMatrix{M,N}) where {M,N}\nsnf_with_transform(mat::Matrix)\n\nWrapper of Nemo.snfwithtransform. Input is converted to BigInt. Returns (S,U,V) such that UmatV = S, where S is the Smith normal form of mat.\n\nExample\n\njulia> using ALFA # hide\n\njulia> using LinearAlgebra # hide\n\njulia> mat = rand(1:10, 10, 10);\n\njulia> (S,U,V) = ALFA.snf_with_transform(mat);\n\njulia> norm(U*mat*V - S) ≈ 0\ntrue\n\njulia> abs(det(U)) ≈ abs(det(V)) ≈ 1\ntrue\n\njulia> norm(diagm(diag(S)) - S) ≈ 0\ntrue\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.symbol-Tuple{ALFA.CrystalOperator, Any}","page":"Internals","title":"ALFA.symbol","text":"symbol(S::CrystalOperator, k; π = π)\nsymbol(O::OperatorComposition, k; π = π)\n\nReturns the symbol of the CrystalOperator/OperatorComposition for a given frequency/wavevector k.\n\nExample\n\njulia> using ALFA\n\njulia> L = ALFA.gallery.Laplace(N=2);\n\njulia> oc = ALFA.OperatorComposition(:(3*$L));\n\njulia> ALFA.symbol(oc,[0.5, 0.5]) ≈ [-24] # as f is the identitity, the fourier transform is 1 for all frequencies.\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.CrystalOperator{N, T}, Any}, Tuple{ALFA.CrystalOperator{N, T}, Any, Any}, Tuple{ALFA.CrystalOperator{N, T}, Any, Any, Any}} where {N, T}","page":"Internals","title":"ALFA.wrtLattice","text":"wrtLattice(\n    S::CrystalOperator{N,T},\n    A,\n    _CompatibilityCheckOnly = false,\n    normalize = true\n) where {N,T}\n\nRewrites the crystaloperator S wit hrespect to the translationally invariance A.\n\nExample\n\njulia> using ALFA\n\njulia> L = ALFA.gallery.Laplace(N=1)\nLattice Basis: ALFA.Lattice{1, Float64}([1.0;;])\nDomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nMultiplier: 3-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], [1.0;;])\n ALFA.Multiplier{1}([0], [-2.0;;])\n ALFA.Multiplier{1}([1], [1.0;;])\n\njulia> ALFA.wrtLattice(L, L.C.L.A*2)\nLattice Basis: ALFA.Lattice{1, Float64}([2.0;;])\nDomain: 2-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\n [1.0]\nCodomain: 2-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\n [1.0]\nMultiplier: 3-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], [0.0 1.0; 0.0 0.0])\n ALFA.Multiplier{1}([0], [-2.0 1.0; 1.0 -2.0])\n ALFA.Multiplier{1}([1], [0.0 0.0; 1.0 0.0])\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.wrtLattice-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.Crystal{N, T}, Any}} where {N, T}","page":"Internals","title":"ALFA.wrtLattice","text":"wrtLattice(C::Crystal, L::Lattice)\nwrtLattice(C::Crystal{N,T}, A) where {N,T}\n\nRewrites the crystal with respect to L::Lattice or lattice basis A. Thus, the lattice must be a sublattice of C.L.\n\nExample\n\njulia> using ALFA\n\njulia> using LinearAlgebra\n\njulia> C = ALFA.Crystal{2,Float64}()\nLattice Basis: ALFA.Lattice{2, Float64}([1.0 0.0; 0.0 1.0])\nDomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\n\njulia> L = ALFA.Lattice{2, Float64}(2*I)\nALFA.Lattice{2, Float64}([2.0 0.0; 0.0 2.0])\n\njulia> ALFA.wrtLattice(C,L)\nLattice Basis: ALFA.Lattice{2, Float64}([2.0 0.0; 0.0 2.0])\nDomain: 4-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\n [1.0, 0.0]\n [0.0, 1.0]\n [1.0, 1.0]\nCodomain: 4-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\n [1.0, 0.0]\n [0.0, 1.0]\n [1.0, 1.0]\n\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#ALFA.wrtSameLatticeAndNormalize-Tuple{ALFA.CrystalOperator, ALFA.CrystalOperator}","page":"Internals","title":"ALFA.wrtSameLatticeAndNormalize","text":"wrtSameLatticeAndNormalize(A::CrystalOperator, B::CrystalOperator)\n\nFinds a least common multiple translationally invariance C and rewrites both operators A and B wrt C and normalizes the Operators.\n\nExample\n\njulia> using ALFA\n\njulia> A = ALFA.gallery.Laplace(N=1)\nLattice Basis: ALFA.Lattice{1, Float64}([1.0;;])\nDomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nMultiplier: 3-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], [1.0;;])\n ALFA.Multiplier{1}([0], [-2.0;;])\n ALFA.Multiplier{1}([1], [1.0;;])\n\njulia> B = ALFA.gallery.fw_restriction(N=1)\nLattice Basis: ALFA.Lattice{1, Float64}([2.0;;])\nDomain: 2-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\n [1.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nMultiplier: 2-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], Rational{Int64}[0//1 1//2])\n ALFA.Multiplier{1}([0], Rational{Int64}[1//1 1//2])\n\njulia> (A2,B2) = ALFA.wrtSameLatticeAndNormalize(A,B);\n\njulia> A2\nLattice Basis: ALFA.Lattice{1, Float64}([2.0;;])\nDomain: 2-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\n [1.0]\nCodomain: 2-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\n [1.0]\nMultiplier: 3-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], [0.0 1.0; 0.0 0.0])\n ALFA.Multiplier{1}([0], [-2.0 1.0; 1.0 -2.0])\n ALFA.Multiplier{1}([1], [0.0 0.0; 1.0 0.0])\n\njulia> B2\nLattice Basis: ALFA.Lattice{1, Float64}([2.0;;])\nDomain: 2-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\n [1.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nMultiplier: 2-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], Rational{Int64}[0//1 1//2])\n ALFA.Multiplier{1}([0], Rational{Int64}[1//1 1//2])\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.CrystalOperator{N, T}, ALFA.CrystalOperator{N, T}}} where {N, T}","page":"Internals","title":"Base.:*","text":"Base.:*(A::CrystalOperator{N,T}, B::CrystalOperator{N,T}) where {N,T}\n\nIf there is a least common multiple translationally invariance of A and B, then both operators A and B are rewritten wrt this translationally invariance A2 and B2. After that, it is checked if domain and codomain are compatible. If thats the case, the crystaloperator A2\\cdot B2 is constructed.\n\nA2cdot B2  mathcalL(B2CL^textDomain) rightarrow mathcalL(A2CL^textCodomain)\n\nwith\n\n(A2cdot B2cdot f)(x) = sum_a in A2M b in B2M atextmatcdot btextmat  f(x+atextpos+btextpos) quad forall x in (A2CLA)mathbbZ^N\n\nExample\n\njulia> using ALFA\n\njulia> A = ALFA.gallery.Laplace(N=1)\nLattice Basis: ALFA.Lattice{1, Float64}([1.0;;])\nDomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nMultiplier: 3-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], [1.0;;])\n ALFA.Multiplier{1}([0], [-2.0;;])\n ALFA.Multiplier{1}([1], [1.0;;])\n\njulia> R = ALFA.gallery.fw_restriction(N=1)\nLattice Basis: ALFA.Lattice{1, Float64}([2.0;;])\nDomain: 2-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\n [1.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nMultiplier: 2-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], Rational{Int64}[0//1 1//2])\n ALFA.Multiplier{1}([0], Rational{Int64}[1//1 1//2])\n\njulia> R*A\nLattice Basis: ALFA.Lattice{1, Float64}([2.0;;])\nDomain: 2-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\n [1.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nMultiplier: 3-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], [0.5 0.0])\n ALFA.Multiplier{1}([0], [-1.0 0.0])\n ALFA.Multiplier{1}([1], [0.5 0.0])\n\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#Base.:*-Union{Tuple{T}, Tuple{T, ALFA.CrystalOperator}} where T<:Number","page":"Internals","title":"Base.:*","text":"Base.:*(b::T, A::CrystalOperator) where {T<:Number}\nBase.:*(A::CrystalOperator{N,T}, b::S) where {N,T,S<:Number}\n\nConstructs a translationally invariant C::CrystalOperators{N,T}\n\nbcdot C  mathcalL(CL^textDomain) rightarrow mathcalL(CL^textCodomain)\n\nwith\n\n(bcdot Ccdot f)(x) = bcdot sum_y in CM ytextmat  f(x+ytextpos) quad forall x in (CLA)mathbbZ^N\n\nExample\n\njulia> using ALFA\n\njulia> L = ALFA.gallery.Laplace(N=1)\nLattice Basis: ALFA.Lattice{1, Float64}([1.0;;])\nDomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nMultiplier: 3-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], [1.0;;])\n ALFA.Multiplier{1}([0], [-2.0;;])\n ALFA.Multiplier{1}([1], [1.0;;])\n\njulia> 2L\nLattice Basis: ALFA.Lattice{1, Float64}([1.0;;])\nDomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nMultiplier: 3-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], [2.0;;])\n ALFA.Multiplier{1}([0], [-4.0;;])\n ALFA.Multiplier{1}([1], [2.0;;])\n\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#Base.:+-Union{Tuple{T}, Tuple{N}, Tuple{ALFA.CrystalOperator{N, T}, ALFA.CrystalOperator{N, T}}} where {N, T}","page":"Internals","title":"Base.:+","text":"Base.:+(A::CrystalOperator{N,T}, B::CrystalOperator{N,T}) where {N,T}\n\nIf there is a least common multiple translationally invariance of A and B, then both operators A and B are rewritten wrt this translationally invariance A2 and B2. After that, it is checked if domain and codomain are compatible. If thats the case, the crystaloperator A2+t B2 is constructed.\n\nA2+B2  mathcalL(A2CL^textDomain) rightarrow mathcalL(A2CL^textCodomain)\n\nwith\n\n(A2+B2cdot f)(x) = (A2cdot f)(x) + (B2cdot f)(x) quad forall x in (A2CLA)mathbbZ^N\n\nExample\n\njulia> using ALFA\n\njulia> A = ALFA.gallery.Laplace(N=1)\nLattice Basis: ALFA.Lattice{1, Float64}([1.0;;])\nDomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nMultiplier: 3-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], [1.0;;])\n ALFA.Multiplier{1}([0], [-2.0;;])\n ALFA.Multiplier{1}([1], [1.0;;])\n\njulia> A+A\nLattice Basis: ALFA.Lattice{1, Float64}([1.0;;])\nDomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nMultiplier: 3-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], [2.0;;])\n ALFA.Multiplier{1}([0], [-4.0;;])\n ALFA.Multiplier{1}([1], [2.0;;])\n\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#Base.:/-Union{Tuple{T}, Tuple{ALFA.CrystalOperator, T}} where T<:Number","page":"Internals","title":"Base.:/","text":"Base.:/(A::CrystalOperator, b::T) where {T<:Number}\n\nConstructs a translationally invariant C::CrystalOperators{N,T}\n\nCb  mathcalL(CL^textDomain) rightarrow mathcalL(CL^textCodomain)\n\nwith\n\n(Cbcdot f)(x) = frac1b sum_y in CM ytextmat  f(x+ytextpos) quad forall x in (CLA)mathbbZ^N\n\nExample\n\njulia> using ALFA\n\njulia> L = ALFA.gallery.Laplace(N=1)\nLattice Basis: ALFA.Lattice{1, Float64}([1.0;;])\nDomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nMultiplier: 3-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], [1.0;;])\n ALFA.Multiplier{1}([0], [-2.0;;])\n ALFA.Multiplier{1}([1], [1.0;;])\n\njulia> L/2\nLattice Basis: ALFA.Lattice{1, Float64}([1.0;;])\nDomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{1, Float64}}:\n [0.0]\nMultiplier: 3-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{1}([-1], [0.5;;])\n ALFA.Multiplier{1}([0], [-1.0;;])\n ALFA.Multiplier{1}([1], [0.5;;])\n\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#Base.getindex-Tuple{ALFA.Lattice, Vararg{Any}}","page":"Internals","title":"Base.getindex","text":"Base.getindex(L::Lattice, y...)\n\nsimply wrapping getindex(L.A, y...).\n\nExample\n\njulia> using ALFA\n\njulia> L = ALFA.Lattice{2, Float64}([1 2; 3 4])\nALFA.Lattice{2, Float64}([1.0 2.0; 3.0 4.0])\njulia> L[1,2] == L.A[1,2]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#Base.getproperty-Tuple{ALFA.Lattice, Symbol}","page":"Internals","title":"Base.getproperty","text":"Base.getproperty(L::Lattice, sym::Symbol)\n\nGet properties of Lattice{N,T}. Let A=L.A, i.e., A  T^N  N, then\n\nL.n and L.dim return the dimension N.\nL.iA returns A^-1, i.e., the inverse of the lattice basis\nL.dA returns A^-T, i.e., the basis of the dual lattice.\n\nExample\n\njulia> using ALFA\n\njulia> L = ALFA.Lattice{2, Float64}([1 2; 3 4])\nALFA.Lattice{2, Float64}([1.0 2.0; 3.0 4.0])\n\njulia> L.n == L.dim == typeof(L).parameters[1] == 2\ntrue\njulia> L[2,1]\n3.0\njulia> L.iA == inv(L.A)\ntrue\njulia> L.dA == transpose(inv(L.A))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#Base.lcm-Union{Tuple{T}, Tuple{X}, Tuple{StaticArraysCore.MArray{X, T}, StaticArraysCore.MArray{X, T}}} where {X, T<:Real}","page":"Internals","title":"Base.lcm","text":"Base.lcm(A::MArray{X,T},B::MArray{X,T}...)\nBase.lcm(A::MArray{X,T}, B::MArray{X,T}...) where {X,T<:Rational}\n\nBase.lcm(A::Lattice{N,T}, B::Lattice{N,T}...) where {N,T}\nBase.lcm(A::MArray{X,T}, B::MArray{X,T}...) where {X,T<:Rational}\n\nReturns the least common multiple of A and B (or more), i.e. a sub-lattice C, that is C  A and C  B with det(C) as small as possible.\n\nSee Algorithm B.7, Theorem 5.1 in [1].\n\nExample\n\njulia> using ALFA\n\njulia> L = ALFA.Lattice{2, Float64}([1 2; 3 4])\nALFA.Lattice{2, Float64}([1.0 2.0; 3.0 4.0])\n\njulia> ALFA.lcm(L) == L\ntrue\n\njulia> ALFA.lcm(L.A) == L.A\ntrue\n\njulia> ALFA.lcm(ALFA.Lattice{1,Float64}([2]), ALFA.Lattice{1,Float64}([3]), ALFA.Lattice{1,Float64}([6]))\nALFA.Lattice{1, Float64}([6.0;;])\n\njulia> ALFA.lcm(ALFA.Lattice{2,Rational{BigInt}}([1 1; -1 1]), ALFA.Lattice{2,Rational{BigInt}}([1 2; 2 1]))\nALFA.Lattice{2, Rational{BigInt}}(Rational{BigInt}[-3//1 1//1; -3//1 -1//1])\n\n\n\n\n\n","category":"method"},{"location":"internals/internals/#Base.push!","page":"Internals","title":"Base.push!","text":"Base.push!(S::CrystalOperator, m::Multiplier, add_to_existing = false)\n\nAdds a multiplier to S.M. If there is a multiplier m2 in S.M with m2.pos == m.pos, then\n\nm2 is replaced if add_to_existing == false\nm2.mat+m.mat is the new multiplier at m.pos if add_to_existing == true.\n\nExample\n\njulia> using ALFA\n\njulia> S = ALFA.gallery.Laplace()\nLattice Basis: ALFA.Lattice{2, Float64}([1.0 0.0; 0.0 1.0])\nDomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nMultiplier: 5-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{2}([-1, 0], [1.0;;])\n ALFA.Multiplier{2}([0, -1], [1.0;;])\n ALFA.Multiplier{2}([0, 0], [-4.0;;])\n ALFA.Multiplier{2}([0, 1], [1.0;;])\n ALFA.Multiplier{2}([1, 0], [1.0;;])\n\njulia> m = ALFA.Multiplier{2}([0, 0], [1])\nPosition: 2-element StaticArraysCore.MVector{2, Int64} with indices SOneTo(2):\n 0\n 0\nMultiplier: 1×1 Matrix{Int64}:\n 1\n\njulia> push!(S,m)\nLattice Basis: ALFA.Lattice{2, Float64}([1.0 0.0; 0.0 1.0])\nDomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nMultiplier: 5-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{2}([-1, 0], [1.0;;])\n ALFA.Multiplier{2}([0, -1], [1.0;;])\n ALFA.Multiplier{2}([0, 0], [1;;])\n ALFA.Multiplier{2}([0, 1], [1.0;;])\n ALFA.Multiplier{2}([1, 0], [1.0;;])\n\njulia> push!(S,m, true)\nLattice Basis: ALFA.Lattice{2, Float64}([1.0 0.0; 0.0 1.0])\nDomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nCodomain: 1-element Vector{StaticArraysCore.SVector{2, Float64}}:\n [0.0, 0.0]\nMultiplier: 5-element Vector{ALFA.Multiplier}:\n ALFA.Multiplier{2}([-1, 0], [1.0;;])\n ALFA.Multiplier{2}([0, -1], [1.0;;])\n ALFA.Multiplier{2}([0, 0], [2;;])\n ALFA.Multiplier{2}([0, 1], [1.0;;])\n ALFA.Multiplier{2}([1, 0], [1.0;;])\n\n\n\n\n\n\n","category":"function"},{"location":"internals/internals/#Base.size-Tuple{ALFA.Lattice}","page":"Internals","title":"Base.size","text":"Base.size(L::Lattice)\n\nReturns the dimension of the lattice basis: size(L.A,1).\n\nExample\n\njulia> using ALFA\n\njulia> L = ALFA.Lattice{2, Float64}([1 2; 3 4])\nALFA.Lattice{2, Float64}([1.0 2.0; 3.0 4.0])\njulia> size(L) == size(L.A) == (2,2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"internals/gallery/#Gallery","page":"Gallery","title":"Gallery","text":"","category":"section"},{"location":"internals/gallery/","page":"Gallery","title":"Gallery","text":"Pages = [\"gallery.md\"]","category":"page"},{"location":"internals/gallery/","page":"Gallery","title":"Gallery","text":"Modules = [ALFA.gallery]","category":"page"},{"location":"internals/gallery/#ALFA.gallery.Laplace-Tuple{}","page":"Gallery","title":"ALFA.gallery.Laplace","text":"Laplace(;N = 2, h=1, T = Float64)\n\nCreates a CrystalOperator corresponding to the (central differences) discretization of the Laplace operator Δ=sum_j fracpartial^2partial x_j^2in N dimensions.\n\nh corresponds to the distance of the grid points.\n\n\n\n\n\n","category":"method"},{"location":"internals/gallery/#ALFA.gallery.curlcurl","page":"Gallery","title":"ALFA.gallery.curlcurl","text":"curlcurl(sigma; T=Float64)\n\nCreates the curlcurl operator. See [Section 6.2, 1] Kahl, K., Kintscher, N. Automated local Fourier analysis (ALFA). Bit Numer Math (2020). https://doi.org/10.1007/s10543-019-00797-w\n\n\n\n\n\n","category":"function"},{"location":"internals/gallery/#ALFA.gallery.curlcurl_restriction-Tuple{}","page":"Gallery","title":"ALFA.gallery.curlcurl_restriction","text":"curlcurl_restriction(sigma; T=Float64)\n\nCreates the restriction operator corresponding to the curl curl operator. See [Section 6.2, 1] Kahl, K., Kintscher, N. Automated local Fourier analysis (ALFA). Bit Numer Math (2020). https://doi.org/10.1007/s10543-019-00797-w\n\n\n\n\n\n","category":"method"},{"location":"internals/gallery/#ALFA.gallery.fw_restriction-Tuple{}","page":"Gallery","title":"ALFA.gallery.fw_restriction","text":"fw_restriction(;m=1, N = 2, T = Float64)\n\nFull weighting restriction operator in N dimensions.\n\n\n\n\n\n","category":"method"},{"location":"internals/gallery/#ALFA.gallery.graphene_dirac_restriction-Tuple{}","page":"Gallery","title":"ALFA.gallery.graphene_dirac_restriction","text":"graphene_dirac_restriction(;t = nothing, T=Float64)\n\nCreates a restriction CrystalOperator that conserveres the dirac function. See [Section 6.1, 1] Kahl, K., Kintscher, N. Automated local Fourier analysis (ALFA). Bit Numer Math (2020). https://doi.org/10.1007/s10543-019-00797-w\n\n\n\n\n\n","category":"method"},{"location":"internals/gallery/#ALFA.gallery.graphene_tight_binding-Tuple{}","page":"Gallery","title":"ALFA.gallery.graphene_tight_binding","text":"graphene_tight_binding(;t = nothing, T=Float64)\n\nCreates a CrystalOperator corresponding to the tight-binding Hamiltonian of graphene. The vector t should contain the hopping parameter. See [Section 6.1, 1] Kahl, K., Kintscher, N. Automated local Fourier analysis (ALFA). Bit Numer Math (2020). https://doi.org/10.1007/s10543-019-00797-w\n\n\n\n\n\n","category":"method"},{"location":"examples/example_03/#Example-3:-Half-hybrid-smoother-for-the-curl-curl-equation","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Example 3: Half-hybrid smoother for the curl-curl equation","text":"","category":"section"},{"location":"examples/example_03/","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Example 3: Half-hybrid smoother for the curl-curl equation","text":"In here we use this framework to analyze the half hybrid smoother for the curl-curl equation as described in [2] https://epubs.siam.org/doi/abs/10.1137/S0036142997326203, and analyzed in [3] https://epubs.siam.org/doi/abs/10.1137/070679119.","category":"page"},{"location":"examples/example_03/","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Example 3: Half-hybrid smoother for the curl-curl equation","text":"It corresponds to section 6.2 of [1] Kahl, K., Kintscher, N. Automated local Fourier analysis (ALFA). Bit Numer Math (2020). https://doi.org/10.1007/s10543-019-00797-w.","category":"page"},{"location":"examples/example_03/#Definition-of-the-operators","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Definition of the operators","text":"","category":"section"},{"location":"examples/example_03/","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Example 3: Half-hybrid smoother for the curl-curl equation","text":"using ALFA\nusing LinearAlgebra\nusing Plots\nusing SparseArrays","category":"page"},{"location":"examples/example_03/#System-and-restriction-operator","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"System & restriction operator","text":"","category":"section"},{"location":"examples/example_03/","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Example 3: Half-hybrid smoother for the curl-curl equation","text":"L = ALFA.gallery.curlcurl(.01)\np1 = plot(L, title=\"L\")\n\nR = ALFA.gallery.curlcurl_restriction()\np2 = plot(R, title=\"R\")\n\nP = R'\nLc = R*L*P\n\n(w,h) = p1.attr[:size]\nplot(p1, p2, layout=(2,1), size=(w,2h))\n","category":"page"},{"location":"examples/example_03/#Hybrid-smoother","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Hybrid smoother","text":"","category":"section"},{"location":"examples/example_03/#The-Discrete-gradient-operator","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"The Discrete gradient operator","text":"","category":"section"},{"location":"examples/example_03/","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Example 3: Half-hybrid smoother for the curl-curl equation","text":"A = [1 0; 0 1]\nDomain = [[.5, 0],[0, .5]]\nCodomain = [[0,0]]\n\nC = ALFA.Crystal{2,Float64}(A, Domain, Codomain)\nRs = ALFA.CrystalOperator{2,Float64}(C)\n\npush!(Rs, ALFA.Multiplier([0 0], [-1 -1]))\npush!(Rs, ALFA.Multiplier([-1 0], [1 0]))\npush!(Rs, ALFA.Multiplier([0 -1], [0 1]))\n\nPs = Rs'\nLs = Rs*L*Ps\n\np1 = plot(Rs, title=\"Rs\")\np2 = plot(Ps, title=\"Ps\")\np3 = plot(Ls, title=\"Ls\")\nplot(p1, p2, p3, layout=(3,1), size=(w,3h))\n","category":"page"},{"location":"examples/example_03/#Gauss-Seidel-on-vertices","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Gauss-Seidel on vertices","text":"","category":"section"},{"location":"examples/example_03/","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Example 3: Half-hybrid smoother for the curl-curl equation","text":"\n# We have to change to lexicographic ordering in order to obtain the same operator as described in [3]\nS1 = ALFA.CrystalOperatorCopyLowerTriangle(Ls,perm=[2,1])\nplot(S1)","category":"page"},{"location":"examples/example_03/#scalar-Gauss-Seidel-on-edges","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"scalar Gauss-Seidel on edges","text":"","category":"section"},{"location":"examples/example_03/","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Example 3: Half-hybrid smoother for the curl-curl equation","text":"# change the structure element in order to obtain the same operator as described in [3]\ns0_lex = [[.5,0],[1,-.5]]\nL_lex = ALFA.ChangeStructureElement(L, s0_lex, s0_lex)\nS0 = ALFA.CrystalOperatorCopyLowerTriangle(L_lex, perm=[2,1])\n\n#Now, S0 describes a block-Gauss-Seidel smoother. We need to use the lower triangle of the central multiplier.\nm = ALFA.find_multiplier(S0, [0,0])\nm.mat = tril(m.mat)\n\nplot(S0)","category":"page"},{"location":"examples/example_03/#Spectrum-of-the-smoother","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Spectrum of the smoother","text":"","category":"section"},{"location":"examples/example_03/","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Example 3: Half-hybrid smoother for the curl-curl equation","text":"f_edge = :(I-pinv($S0)*$L)\nf_node = :(I-$Ps*pinv($S1)*$Rs*$L)\n\noc_s = ALFA.OperatorComposition(f_edge*f_node)\nplotspectrum(oc_s, N=30)","category":"page"},{"location":"examples/example_03/#Spectrum-of-the-twogrid-method","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Spectrum of the twogrid method","text":"","category":"section"},{"location":"examples/example_03/","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Example 3: Half-hybrid smoother for the curl-curl equation","text":"f_cgc = :(I-$P*inv($Lc)*$R*$L)\n\noc_tg = ALFA.OperatorComposition(f_node*f_edge*f_cgc*f_node*f_edge)\nplotspectrum(oc_tg, N=30)","category":"page"},{"location":"examples/example_03/#Double-check-result-with-a-twogrid-implementation","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Double check result with a twogrid implementation","text":"","category":"section"},{"location":"examples/example_03/","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Example 3: Half-hybrid smoother for the curl-curl equation","text":"wrtL = ALFA.Lattice{2, Float64}(30*[1.0 0; 0 1.0])\nLm = SparseMatrixCSC{Float64,Int}(ALFA.construct_matrix(L,wrtL))\nRm = SparseMatrixCSC{Float64,Int}(ALFA.construct_matrix(R,wrtL))\nPm = SparseMatrixCSC{Float64,Int}(ALFA.construct_matrix(P,wrtL))\nLcm = SparseMatrixCSC{Float64,Int}(ALFA.construct_matrix(Lc,wrtL))\nS0m = SparseMatrixCSC{Float64,Int}(ALFA.construct_matrix(S0,wrtL))\nS1m = SparseMatrixCSC{Float64,Int}(ALFA.construct_matrix(S1,wrtL))\nRsm = SparseMatrixCSC{Float64,Int}(ALFA.construct_matrix(Rs,wrtL))\nPsm = SparseMatrixCSC{Float64,Int}(ALFA.construct_matrix(Ps,wrtL))\n\nnothing # hide","category":"page"},{"location":"examples/example_03/#Definition-of-the-application-of-the-smoother-and-coarse-grid-correction","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Definition of the application of the smoother and coarse grid correction","text":"","category":"section"},{"location":"examples/example_03/","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Example 3: Half-hybrid smoother for the curl-curl equation","text":"S0mLU = lu(S0m)\nS1mLU = lu(S1m)\nLcmLU = lu(Lcm)\n\n\nfunction smooth_edge(b, x)\n    r = b-Lm*x\n    x += (S0mLU\\r)\n    return x\nend\n\n\nfunction smooth_node(b, x)\n    r = b-Lm*x\n    rc = Rsm*r\n    xc = S1mLU\\rc\n    x += Psm*xc\n    return x\nend\n\nfunction cgc(b, x)\n    r = b-Lm*x\n    rc = Rm*r\n    xc = LcmLU\\rc\n    x += Pm*xc\n    return x\nend\nnothing # hide","category":"page"},{"location":"examples/example_03/#Testrun-of-the-twogrid-method.","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Testrun of  the twogrid method.","text":"","category":"section"},{"location":"examples/example_03/","page":"Example 3: Half-hybrid smoother for the curl-curl equation","title":"Example 3: Half-hybrid smoother for the curl-curl equation","text":"\n# initialize rhs and initial guess\nglobal x, b, casym_vec, resnorm_vec, num_iter\nn = size(Lm,1);\nx = Lm*rand(n);\nx = x/norm(x)\nb = 0*Lm*rand(n);\n\ncasym_vec = [1.0]\nresnorm_vec = [1.0]\n\nnum_iter = 0\n\nwhile resnorm_vec[end] > 1e-200 && num_iter < 175\n    global x, b, casym_vec, resnorm_vec, num_iter\n    num_iter = num_iter + 1\n    x = smooth_edge(b,x)\n    x = smooth_node(b,x)\n    x = cgc(b,x)\n    x = smooth_edge(b,x)\n    x = smooth_node(b,x)\n    push!(resnorm_vec, norm(b - Lm*x))\n    push!(casym_vec, resnorm_vec[end]/resnorm_vec[end-1])\nend\n\n# plot convergence behavior.\nplot(resnorm_vec, yaxis=:log, xlabel=\"iteration\", ylabel=\"residual norm\", title=\"measured asymptotic convrate=\"*string(casym_vec[end])*\"\\n conv.rate from analysis: \"*string(abs(ALFA.eigvals(oc_tg,N=30)[end])))\n","category":"page"},{"location":"examples/example_02/#Example-2:-Colored-overlapping-smoother-for-graphene","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"","category":"section"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"In here we use the ALFA framework to analyze a 4 color overlap smoother for the tight-binding Hamiltonian of graphene.","category":"page"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"It corresponds to section 6.1 of [1] Kahl, K., Kintscher, N. Automated local Fourier analysis (ALFA). Bit Numer Math (2020). https://doi.org/10.1007/s10543-019-00797-w.","category":"page"},{"location":"examples/example_02/#Definition-of-the-operators","page":"Example 2: Colored overlapping smoother for graphene","title":"Definition of the operators","text":"","category":"section"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"using ALFA\nusing LinearAlgebra\nusing Plots","category":"page"},{"location":"examples/example_02/#System-operator","page":"Example 2: Colored overlapping smoother for graphene","title":"System operator","text":"","category":"section"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"L = ALFA.gallery.graphene_tight_binding()\nplot(L)","category":"page"},{"location":"examples/example_02/#Restriction-operator-of-the-two-grid-method","page":"Example 2: Colored overlapping smoother for graphene","title":"Restriction operator of the two-grid method","text":"","category":"section"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"R = ALFA.gallery.graphene_dirac_restriction(wl=.25, wlh=.25)\nplot(R)","category":"page"},{"location":"examples/example_02/#Prolongation-and-coarse-grid-operator","page":"Example 2: Colored overlapping smoother for graphene","title":"Prolongation and coarse grid operator","text":"","category":"section"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"P = R'\nLc = R*L*P\n\np1 = plot(P, title=\"P\",  aspect_ratio=:equal)\np2 = plot(Lc, title=\"Lc\",  aspect_ratio=:equal)\n(w,h) = p1.attr[:size]\nplot(p1, p2, layout=(2,1), size=(w,2h))","category":"page"},{"location":"examples/example_02/#Smoother-definition","page":"Example 2: Colored overlapping smoother for graphene","title":"Smoother definition","text":"","category":"section"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"We first rewrite the system operator L with respect to the translational invariance 2A, where A=LCLA","category":"page"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"slat = ALFA.Lattice{2, Float64}(2*L.C.L.A)\nLs = ALFA.wrtLattice(L,slat)\nplot(Ls)","category":"page"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"We now construct the 4 operators used in the four color smoother.","category":"page"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"idx=[2,3,4,5,6,7] #\nshifts = [[i,j] for i in [0,1] for j in [0,1]]\nS = []\np = []\nfor (it,x) in enumerate(shifts)\n   se = [y + L.C.L.A*x for y in Ls.C.Domain]\n   Ls_tmp = ALFA.ChangeStructureElement(Ls, se, se)\n   push!(S, ALFA.CrystalOperatorCopyWithMultipliers(Ls_tmp, idx=idx))\n   push!(p, plot(S[it], title=\"S[$it]\"))\nend\nplot(p..., layout=(2,2), size=(1.5w,1.5h))","category":"page"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"... and normalize the operators S for illustrative purposes:","category":"page"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"p = []\nfor (j,s) in enumerate(S)\n   S[j] = ALFA.normalize(s)\n   push!(p, plot(S[j], title=\"S[$j]\"))\nend\nplot(p..., layout=(2,2), size=(1.5w,1.5h))","category":"page"},{"location":"examples/example_02/#Spectrum-of-the-error-propagator-of-the-Smoother","page":"Example 2: Colored overlapping smoother for graphene","title":"Spectrum of the error propagator of the Smoother","text":"","category":"section"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"Now we construct the error propagator of the smoother and plot its spectrum","category":"page"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"f_s = prod(:(I-0.5*pinv($s)*$L) for s in S)\noc_s = ALFA.OperatorComposition(f_s)\nplotspectrum(oc_s, N=41)","category":"page"},{"location":"examples/example_02/#Spectrum-of-the-error-propagator-of-the-two-grid-method","page":"Example 2: Colored overlapping smoother for graphene","title":"Spectrum of the error propagator of the two-grid method","text":"","category":"section"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"Finally, we analyze the two-grid error propagator","category":"page"},{"location":"examples/example_02/","page":"Example 2: Colored overlapping smoother for graphene","title":"Example 2: Colored overlapping smoother for graphene","text":"f_cgc = :(I-$P*inv($Lc)*$R*$L)\nf_tg = f_s*f_cgc*f_s\noc_tg = ALFA.OperatorComposition(f_tg)\nplotspectrum(oc_tg, N=41)","category":"page"},{"location":"#ALFA.jl-:-Automated-Local-Fourier-Analysis","page":"Home","title":"ALFA.jl : Automated Local Fourier Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Kahl, K., Kintscher, N. Automated local Fourier analysis (aLFA). Bit Numer Math (2020). https://doi.org/10.1007/s10543-019-00797-w","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main purpose of this framework is to enable the reliable and easy-to-use analysis of complex methods on repetitive structures, e.g.,  multigrid methods with complex overlapping block smoothers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Throughout this framework we refer to definitions, theorems, lemmata and algorithms in [1].","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As this package is registered with the General Registry, it can be installed via Julia's Package Manager as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ALFA\")","category":"page"},{"location":"#Some-remarks:","page":"Home","title":"Some remarks:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you only want to use this framework to analyze an operator or a method/composition of operators, you may try to proceed in the same way as in the examples: The examples in [1] can be found in the documentation of this framework.\nIf you are interested in the core algorithms and want to understand this framework completely, I recommend to read [1] completely before digging into the source code of this repository.\nSeveral unit tests of this framework are done with randomly generated crystal operators which can lead to very ill-conditioned problems. Thus, these tests may fail in case the datatype used for the lattice basis and structure elements is  T::Float64. As this cannot be avoided when using floating-point arithmetic, the tests don't throw an error if at least 95 pass. This should not be a problem in actual applications. Nevertheless, there exist rational versions ( T::Rational{BigInt}) of these algorithms which are very reliable, but also slower.","category":"page"}]
}
