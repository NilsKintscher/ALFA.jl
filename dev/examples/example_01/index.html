<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example 1: Tutorial · ALFA.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ALFA.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Example 1: Tutorial</a><ul class="internal"><li><a class="tocitem" href="#The-discretized-Laplacian-L-in-2D-1"><span>The discretized Laplacian <span>$L$</span> in 2D</span></a></li><li><a class="tocitem" href="#Computing-the-spectrum-of-L-1"><span>Computing the spectrum of <span>$L$</span></span></a></li><li><a class="tocitem" href="#Obtaining-a-system-matrix-A-from-a-multiplication-operator-L-1"><span>Obtaining a system matrix <span>$A$</span> from a multiplication operator <span>$L$</span></span></a></li><li><a class="tocitem" href="#A-link-between-the-the-eigenvalues-of-A-and-L_k-1"><span>A link between the the eigenvalues of <span>$A$</span> and <span>$L_k$</span></span></a></li><li class="toplevel"><a class="tocitem" href="#Analysis-of-stationary-iterative-methods-1"><span>Analysis of stationary iterative methods</span></a></li><li><a class="tocitem" href="#The-Jacobi-method-1"><span>The Jacobi method</span></a></li><li><a class="tocitem" href="#Lexicographic-Gauss-Seidel-smoothing-1"><span>Lexicographic Gauss-Seidel smoothing</span></a></li><li><a class="tocitem" href="#A-colored-smoother:-red-black-Gauss-Seidel-1"><span>A colored smoother: red-black Gauss-Seidel</span></a></li><li><a class="tocitem" href="#Prototyping-a-two-grid-method-1"><span>Prototyping a two-grid method</span></a></li><li><a class="tocitem" href="#Definition-of-the-application-of-the-smoother-and-coarse-grid-correction-1"><span>Definition of the application of the smoother and coarse grid correction</span></a></li><li><a class="tocitem" href="#Testrun-of-the-twogrid-method.-1"><span>Testrun of  the twogrid method.</span></a></li></ul></li><li><a class="tocitem" href="../example_02/">Example 2: Colored overlapping smoother for graphene</a></li><li><a class="tocitem" href="../example_03/">Example 3: Half-hybrid smoother for the curl-curl equation</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../internals/gallery/">Gallery</a></li><li><a class="tocitem" href="../../internals/internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Example 1: Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example 1: Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NilsKintscher/ALFA.jl/blob/master/docs/src/examples/example_01.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Example-1:-Tutorial-1"><a class="docs-heading-anchor" href="#Example-1:-Tutorial-1">Example 1: Tutorial</a><a class="docs-heading-anchor-permalink" href="#Example-1:-Tutorial-1" title="Permalink"></a></h1><p>This example should serve as a tutorial of the aLFA framework. We analyze several components of a two-grid method to solve the linear system of equations <span>$Ax=b$</span>, where <span>$A$</span> corresponds to the two-dimensional Laplacian discretized on an equidistant rectangular lattice.</p><p>This example is structured as follows.</p><ol><li>We define the underyling linear operator: The second order approximation of the two-dimensional Laplacian <span>$L$</span> obtained via finite central differences (5-point stencil). We further compute its spectrum.</li><li>We show the connection of the operator <span>$L$</span> to the system matrix <span>$A$</span>.</li><li>We introduce and analyze the Jacobi-method.</li><li>We define the coarse grid correction.</li><li>We analyze the two-grid method using the Jacobi-method as a smoother.</li><li>We introduce the lexicographic Gauss-Seidel and red-black Gauss-Seidel smoother and analyze the corresponding two-grid method.</li><li>We use this framework to prototype an actual two-grid method.</li></ol><h3 id="Importing-required-packages-1"><a class="docs-heading-anchor" href="#Importing-required-packages-1">Importing required packages</a><a class="docs-heading-anchor-permalink" href="#Importing-required-packages-1" title="Permalink"></a></h3><pre><code class="language-julia">using alfa
using LinearAlgebra
using Plots</code></pre><h2 id="The-discretized-Laplacian-L-in-2D-1"><a class="docs-heading-anchor" href="#The-discretized-Laplacian-L-in-2D-1">The discretized Laplacian <span>$L$</span> in 2D</a><a class="docs-heading-anchor-permalink" href="#The-discretized-Laplacian-L-in-2D-1" title="Permalink"></a></h2><p>We are going to define the 2D discretized Laplacian <span>$L:\mathcal{L}(\mathbb{L}^s(\mathcal{A})) \rightarrow \mathcal{L}(\mathbb{L}^s(\mathcal{A}))$</span> on an equidistant rectangular lattice. Thus, <span>$\mathbb{L}^s(\mathcal{A})$</span> describes the underlying structure of the domain and codomain of the operator <span>$L$</span>.</p><h3 id="Definition-of-the-underlying-lattice-structure-1"><a class="docs-heading-anchor" href="#Definition-of-the-underlying-lattice-structure-1">Definition of the underlying lattice structure</a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-underlying-lattice-structure-1" title="Permalink"></a></h3><p>First, we need to define a basis of the underlying translational-invariance: an equidistant rectangular lattice is given by</p><div>\[\mathcal{A} = \frac{1}{h}\left[\begin{matrix} 1 &amp; 0 \\ 0 &amp; 1 \end{matrix}\right] = \left[\begin{matrix} \mathcal{a}_1 &amp; \mathcal{a}_2\end{matrix}\right].\]</div><p>The lattice generated by <span>$\mathcal{A}$</span> is the set</p><div>\[\mathbb{L}(\mathcal{A}) = \mathcal{A}\mathbb{Z}^2 = \{x = \alpha_1\mathcal{a}_1 + \alpha_2\mathcal{a}_2 \ : \ \alpha_1,\alpha_2 \in \mathbb{Z}\}\]</div><p>The class alfa.Lattice corresponds to <span>$\mathbb{L}(\mathcal{A})$</span> and is initialized with the matrix <span>$\mathcal{A}$</span>.</p><pre><code class="language-">h = .1  # define h
A = h*[1 0; 0 1]  # 2x2 identity matrix scaled with h

# initialize the lattice;
#In the constructor we need to specify the size/dimensionality (N=2)
# and the datatype of the lattice basis (T=Float64)
#  (the alternative to Float is Rational{BigInt})
LA = alfa.Lattice{2,Float64}(A)  
</code></pre><p>We can plot a section of the lattice. Black arrows correspond to the primitive vectors <span>$a_1$</span> and <span>$a_2$</span></p><pre><code class="language-">plot(LA)</code></pre><h3 id="Definition-of-the-domain-and-codomain-of-the-operator-L-1"><a class="docs-heading-anchor" href="#Definition-of-the-domain-and-codomain-of-the-operator-L-1">Definition of the domain and codomain of the operator <span>$L$</span></a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-domain-and-codomain-of-the-operator-L-1" title="Permalink"></a></h3><p>The structure element <span>$s$</span> of <span>$\mathbb{L}^s(\mathcal{A})$</span> corresponds of the location of the unknowns. We can simply choose <span>$s=(s_1)$</span>, where <span>$s_1=(0,0)$</span>, such that the crystal points coincide with the lattice structure.</p><p>The struct alfa.Crystal is used to represent both crystals corresponding to the domain and codomain of an operator. We initialize it with <code>alfa.Crystal{N,T}(LA,s_domain, s_codomain)</code>, where s<em>domain corresponds to the structure element of the domain, and s</em>codomain corresponds to the structure element of the codomain. (In our case we have s<em>domain = s</em>codomain = <span>$s$</span>):</p><pre><code class="language-">Domain = [[0,0]]
Codomain = [[0,0]]
CA = alfa.Crystal{2,Float64}(LA,Domain,Codomain)</code></pre><p>We can have a plot function to plot a section of a crystal:</p><pre><code class="language-">plot(CA)</code></pre><h3 id="Initializing-the-operator-L-1"><a class="docs-heading-anchor" href="#Initializing-the-operator-L-1">Initializing the operator <span>$L$</span></a><a class="docs-heading-anchor-permalink" href="#Initializing-the-operator-L-1" title="Permalink"></a></h3><p>As we have defined the underlying domain and codomain of our operator, we can initialize the multiplication operator <span>$L$</span>.</p><p>This class represents a multiplication operator corresponding to</p><div>\[(Lf)(x) = \sum_{y \in \mathbb{Z}^\text{d}  } m_L^{y} \cdot f(x+\mathcal{A}y),\]</div><p>for all <span>$x \in \mathbb{L}(\mathcal{A})$</span>, where <span>$d=2$</span> is the dimensionality. Note, that the position of the operator is given in fractional coordinates, not in cartesian coordinates <span>$\mathcal{A}y$</span>, such that <span>$y$</span> is always integral.</p><pre><code class="language-">L = alfa.CrystalOperator{2,Float64}(CA)</code></pre><h3 id="Adding-the-multipliers-of-L-1"><a class="docs-heading-anchor" href="#Adding-the-multipliers-of-L-1">Adding the multipliers of <span>$L$</span></a><a class="docs-heading-anchor-permalink" href="#Adding-the-multipliers-of-L-1" title="Permalink"></a></h3><p>We use <code>push!(L,m)</code> to add multipliers <span>$m_L^{y}$</span> to the operator in order to define the discretized Laplacian. As the structure elements of the domain and codomain are both <span>$1$</span>-dimensional, the matrices m_L^{y} are of size <span>$1\times 1$</span>.</p><p>The multipliers are then saved within a SortedSet L.m which is lexicographically ordered with respect to the position y.</p><pre><code class="language-">push!(L, alfa.Multiplier([0 0], [-4/h^2]))
push!(L, alfa.Multiplier([0 -1], [1/h^2]))
push!(L, alfa.Multiplier([0 1], [1/h^2]))
push!(L, alfa.Multiplier([1 0], [1/h^2]))
push!(L, alfa.Multiplier([-1 0], [1/h^2]))

@show L</code></pre><p>A schematic representation can be created with the plot command.</p><pre><code class="language-">plot(L)</code></pre><h2 id="Computing-the-spectrum-of-L-1"><a class="docs-heading-anchor" href="#Computing-the-spectrum-of-L-1">Computing the spectrum of <span>$L$</span></a><a class="docs-heading-anchor-permalink" href="#Computing-the-spectrum-of-L-1" title="Permalink"></a></h2><p>The spectrum of a CrystalOperator is computed via the <span>$alfa.symbol(L::CrystalOperator,k::Vector)$</span> method, where <span>$k$</span> is the frequency/wavevector.</p><pre><code class="language-">alfa.symbol(L,[0, 0])</code></pre><p>In order to compute or approximate the &quot;complete&quot; spectrum, we divide <span>$[0,1)^\text{d}$</span> into <span>$N^d$</span> equidistant points to get a discretization of the primitive cell of the dual lattice <span>$\mathcal{A}^{-T}[0,1)^\text{d}$</span>. Next, we compute the eigenvalues for each <code>symbol(L,k)</code>, where k is sampled on these <span>$N^d$</span> points.</p><pre><code class="language-">alfa.eigvals(L,N=10)</code></pre><p>We may also save everything in a dataframe via <code>alfa.eigvals_df(L,N=N)</code> or directly produce a plot of the absolut part of the spectrum as follows</p><pre><code class="language-">surfacespectrum(L,N=20)</code></pre><h2 id="Obtaining-a-system-matrix-A-from-a-multiplication-operator-L-1"><a class="docs-heading-anchor" href="#Obtaining-a-system-matrix-A-from-a-multiplication-operator-L-1">Obtaining a system matrix <span>$A$</span> from a multiplication operator <span>$L$</span></a><a class="docs-heading-anchor-permalink" href="#Obtaining-a-system-matrix-A-from-a-multiplication-operator-L-1" title="Permalink"></a></h2><p>We can obtain the system matrix <span>$A$</span> corresponding to the a discretization of the Laplacian on the unit square [0,1]^2 with periodic boundary conditions in two steps.</p><h3 id="Step-1-1"><a class="docs-heading-anchor" href="#Step-1-1">Step 1</a><a class="docs-heading-anchor-permalink" href="#Step-1-1" title="Permalink"></a></h3><p>We rewrite <span>$L$</span> with respect to the sublattice <span>$\mathbb{L}(\mathcal{Z}) \subset \mathbb{L}(\mathcal{A})$</span> with <span>$\mathcal{Z}=\left(\begin{matrix} 1 &amp; 0 \\ 0 &amp; 1 \end{matrix}\right)$</span>.</p><p>Due to the fact that we find <span>$1/h^2 = 100$</span> lattice points in <span>$Z[0,1)^2 \cap \mathbb{L}(\mathcal{A}) =: \tilde{s}$</span>, we obtain an operator</p><div>\[\tilde{A}:\mathcal{L}(\mathbb{L}^{\tilde{s}}(\mathcal{Z})) \rightarrow \mathcal{L}(\mathbb{L}^{\tilde{s}}(\mathcal{A})) \text{ with } (\tilde{A} g)(x) =  \sum_{y \in \mathbb{Z}^\text{d}  } m_{\tilde{A}}^{y} \cdot g(x+\mathcal{Z}y), \quad m_{\tilde{A}} \in \mathbb{C}^{100\times 100}\]</div><pre><code class="language-">using SparseArrays
tA = alfa.wrtLattice(L,alfa.Lattice{2,Float64}([1 0; 0 1]))
tA = alfa.normalize(tA); # make sure all points of the structure elements are within [0,1)^2 and lexicographically ordered.
nothing # hide</code></pre><p>We create a spy plot of all five multipliers of tA. One multiplier corresponds to the interaction of the unknowns within the unit cell. The other four multipliers correspond to the connections beyond the boundaries:</p><pre><code class="language-">using SparseArrays
parr = []
for x in tA.M
    p = spy(SparseMatrixCSC(x.mat), c=:blues, title=&quot;position: &quot; * string(x.pos))
    push!(parr, p)
end
plot(parr...);</code></pre><h3 id="Step-two-1"><a class="docs-heading-anchor" href="#Step-two-1">Step two</a><a class="docs-heading-anchor-permalink" href="#Step-two-1" title="Permalink"></a></h3><p>As we impose periodic boundary conditions on the unit square, all lattice points of <span>$\mathbb{L}(Z)$</span> are identified. Thus, we obtain the system matrix <span>$A$</span> by adding all multipliers of tA.</p><pre><code class="language-">tAm = sum(x.mat for x in tA.M);
spy(SparseMatrixCSC(tAm), c=:blues);</code></pre><h2 id="A-link-between-the-the-eigenvalues-of-A-and-L_k-1"><a class="docs-heading-anchor" href="#A-link-between-the-the-eigenvalues-of-A-and-L_k-1">A link between the the eigenvalues of <span>$A$</span> and <span>$L_k$</span></a><a class="docs-heading-anchor-permalink" href="#A-link-between-the-the-eigenvalues-of-A-and-L_k-1" title="Permalink"></a></h2><p>We can compute the eigenvalues and eigenvectors of <span>$A$</span> and compare them with the eigenvalues computed via LFA:</p><pre><code class="language-">eig1 = abs.(sort(eigvals(tAm), by=abs))
eig2 = abs.(alfa.eigvals(L,N=10, by=abs))

p = plot(eig1, label=&quot;eigenvalues of the system matrix&quot;)
plot!(eig2, label=&quot;eigenvalues computed via the symbol&quot;)
plot!(abs.(eig1.-eig2), label=&quot;pairwise difference of the eigenvalues.&quot;)
</code></pre><p>The eigenvalues are equal as long as N=1/h, where <span>$h$</span> corresponds to the lattice spacing and <span>$N$</span> corresponds to the discretization of the frequency space.</p><h1 id="Analysis-of-stationary-iterative-methods-1"><a class="docs-heading-anchor" href="#Analysis-of-stationary-iterative-methods-1">Analysis of stationary iterative methods</a><a class="docs-heading-anchor-permalink" href="#Analysis-of-stationary-iterative-methods-1" title="Permalink"></a></h1><p>Given a linear system of equations (LSE) <span>$Ax=b$</span>, the Jacobi method produces iterates via</p><div>\[x_{k+1} \leftarrow (I-S^{-1}A)x_k + S^{-1}b,\]</div><p>where <span>$I$</span> is the identity and <span>$S$</span> is simply the diagonal of <span>$A$</span>.</p><p>Denote with <span>$x^* = A^{-1}b$</span> the solution of the LSE and with <span>$e_k = x^* - x_k$</span> the <span>$k$</span>th error. Since</p><div>\[e_{k+1} = (I-S^{-1}A)e_k\]</div><p>the operator <span>$G:=(I-S^{-1}A)$</span> is called error propagator. We are interested in the spectral radius <span>$\rho(G)=\max\{|\lambda |  \ : \ \lambda \text{ Eigenvalue of }G \}$</span>  of the error propagator, as we have</p><div>\[||e_{k+1}|| \approx \rho(G) ||e_{k}||\]</div><p>for large k (if the initial error has a component in the direction of the eigenvector corresponding to the largest absolute eigenvalue).</p><h2 id="The-Jacobi-method-1"><a class="docs-heading-anchor" href="#The-Jacobi-method-1">The Jacobi method</a><a class="docs-heading-anchor-permalink" href="#The-Jacobi-method-1" title="Permalink"></a></h2><h4 id="Definition-of-the-Jacobi-method-1"><a class="docs-heading-anchor" href="#Definition-of-the-Jacobi-method-1">Definition of the Jacobi-method</a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-Jacobi-method-1" title="Permalink"></a></h4><p>We compute the spectrum via LFA, thus we need to define <span>$I$</span> and <span>$S$</span> as multiplication operators. In case of the Jacobi method, the multipliers of</p><div>\[S:\mathcal{L}(\mathbb{L}^s(\mathcal{A})) \rightarrow \mathcal{L}(\mathbb{L}^s(\mathcal{A})), \quad\quad \quad (Sf)(x) = \sum_{y \in \mathbb{Z}^\text{d}  } m_S^{y} \cdot f(x+\mathcal{A}y),\]</div><p>are given by</p><div>\[m_S^{y} = \begin{cases} m_L^{y}  &amp; \text{ if } y = 0 \\ 0 &amp; \text{ else.} \end{cases}\]</div><pre><code class="language-">S_jac = alfa.CrystalOperatorCopyWithMultipliers(L)

plot(S_jac)</code></pre><h3 id="Analysis-of-the-Jacobi-method-1"><a class="docs-heading-anchor" href="#Analysis-of-the-Jacobi-method-1">Analysis of the Jacobi-method</a><a class="docs-heading-anchor-permalink" href="#Analysis-of-the-Jacobi-method-1" title="Permalink"></a></h3><p>We analyze the error propagator of the Jacobi method using underrelaxation of .8.</p><pre><code class="language-">f_jac =:(I-0.8*inv($S_jac)*$L) # construct an expression holding the CrystalOperators S and L.
oc = alfa.OperatorComposition(f_jac)

surfacespectrum(oc, 40) # plot the absolute part of the spectrum using 40^2 points.</code></pre><h3 id="Definition-of-the-two-grid-error-propagator-1"><a class="docs-heading-anchor" href="#Definition-of-the-two-grid-error-propagator-1">Definition of the two-grid error propagator</a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-two-grid-error-propagator-1" title="Permalink"></a></h3><p>We are going to analyze the two-grid method corresponding to the error propagator <span>$KG_1 = (I-P L_c^{-1} RL)\cdot G_1$</span> with <span>$R=P^T$</span>, <span>$L_c = RLP$</span>. Thus, we only have to define the prolongation operator <span>$P$</span> explicitly. This operator maps from a coarse crystal to the fine crystal <span>$\mathbb{L}^s(\mathcal{A})$</span>.</p><p>We use the following coarse grid: <span>$\mathbb{L}^{t}(2\mathcal{A})$</span>, <span>$t=(0,0)$</span>:</p><pre><code class="language-">plot(alfa.Lattice{2,Float64}(2*L.C.A))</code></pre><p>The so-called &#39;full weighting&#39; prolongation operator <span>$P$</span> has a translational invariance of <span>$2\mathcal{A}$</span>. Thus we can define it within this framework as <span>$P : \mathcal{L}(\mathbb{L}^t(2\mathcal{A})) \rightarrow \mathcal{L}(\mathbb{L}^{\hat{s}}(2\mathcal{A})),$</span></p><p>where the codomain <span>$\mathbb{L}^{\hat{s}}(2\mathcal{A})$</span> is a representation of the fine crystal <span>$\mathbb{L}^{s}(\mathcal{A})$</span>, but with respect to the larger translational invariance. This is the case if the structure element consists of all lattice points <span>$\mathbb{L}(\mathcal{A})$</span> found in the primitive cell <span>$2\mathcal{A}[0,1)^2$</span>:  <span>$\hat{s} = \mathbb{L}^s(\mathcal{A}) \cap 2\mathcal{A}[0,1)^2 =  ( s, s + \mathcal{a}_1, s + \mathcal{a}_2, s + \mathcal{a}_1 + \mathcal{a}_2) = ( 0,  \mathcal{a}_1,  \mathcal{a}_2,  \mathcal{a}_1 + \mathcal{a}_2).$</span></p><pre><code class="language-">p_domain = [[0, 0]]  # corresponds to &quot;t&quot; in the above description
# corresponds to \hat{s} in the above description
p_codomain = [A*[0, 0], A*[0, 1], A*[1, 0], A*[1, 1]]


Ccoarse = alfa.Crystal{2,Float64}(2*L.C.A, p_domain, p_codomain)

# a plot of the domain and codomain.
plot(Ccoarse)</code></pre><p>We initialize and define the prolongation operator <span>$P$</span>. This operator maps a value of each coarse grid point to its <span>$9$</span> nearest fine-grid points:</p><pre><code class="language-">P = alfa.CrystalOperator{2,Float64}(Ccoarse)
push!(P, alfa.Multiplier([0,0], [1; 1/2; 1/2; 1/4]))
push!(P, alfa.Multiplier([1,0], [0;   0; 1/2; 1/4]))
push!(P, alfa.Multiplier([0,1], [0; 1/2;   0; 1/4]))
push!(P, alfa.Multiplier([1,1], [0;   0;   0; 1/4]))

plot(P)</code></pre><p>We can compute the restriction operator <span>$R=P^T$</span> and the coarse grid operator <span>$L_c = RLP$</span>.</p><pre><code class="language-">R = transpose(P)
Lc = R*L*P
plot(plot(R), plot(Lc))</code></pre><h3 id="Two-grid-analysis-with-Jacobi-smoothing:-1"><a class="docs-heading-anchor" href="#Two-grid-analysis-with-Jacobi-smoothing:-1">Two-grid analysis with Jacobi smoothing:</a><a class="docs-heading-anchor-permalink" href="#Two-grid-analysis-with-Jacobi-smoothing:-1" title="Permalink"></a></h3><p>As all operators share the translational invariance of <span>$\mathbb{L}(2\mathcal{A})$</span> each operator can be rewritten with respect to this translational invariance. Alltogether, the error propagator is a mapping</p><div>\[KG_1 : \mathcal{L}(\mathbb{L}^{\hat{s}}(2\mathcal{A})) \rightarrow \mathcal{L}(\mathbb{L}^{\hat{s}}(2\mathcal{A})).\]</div><p>As the structure element is of size <span>$4$</span> ( <span>$\hat{s} = ( 0,  \mathcal{a}_1,  \mathcal{a}_2,  \mathcal{a}_1 + \mathcal{a}_2)$</span>), its symbol <span>${(KG_1)}_k$</span> is of size <span>$4\times 4$</span> and we obtain <span>$4$</span> eigenvalues per wavevector <span>$k$</span>.</p><pre><code class="language-">f_cgc = :(I-$P*inv($Lc)*$R*$L)
f_tgj = f_cgc*f_jac
oc_tgj = alfa.OperatorComposition(f_tgj)
alfa.symbol(oc_tgj, [0,0])</code></pre><p>A plot of the absolute part of the spectrum:</p><pre><code class="language-">surfacespectrum(oc_tgj, N=20, zfilter=(0,0.7))</code></pre><p>Note, that the zfilter filters the eigenvalue corresponding to the constant eigenfunction  (<span>$k=(0,0)$</span>) which is in the kernel of <span>$L$</span>.</p><p>The spectral radius of the two-grid error propagator is <span>$.6$</span> when we use underrelaxation of <span>$\omega = .8$</span> in the Jacobi-method. Thus, the norm of an error is reduced by <span>$40\%$</span> in each iteration of the two-grid method.</p><h2 id="Lexicographic-Gauss-Seidel-smoothing-1"><a class="docs-heading-anchor" href="#Lexicographic-Gauss-Seidel-smoothing-1">Lexicographic Gauss-Seidel smoothing</a><a class="docs-heading-anchor-permalink" href="#Lexicographic-Gauss-Seidel-smoothing-1" title="Permalink"></a></h2><p>Given a linear system of equations (LSE) <span>$Ax=b$</span>, the Gauss-Seidel method produces iterates via</p><div>\[x_{k+1} \leftarrow (I-S^{-1}A)x_k + S^{-1}b,\]</div><p>where <span>$I$</span> is the identity and <span>$S$</span> is simply the triangle of <span>$A$</span>. We assume that the unknowns <span>$x_1,x_2,\ldots,x_{1/h^2}$</span> are ordered lexicographically, i.e.,</p><div>\[x_i=(x_{i_1}, x_{i_2}) &lt; x_j=(x_{j_1}, x_{j_2}) \text{ iff } \left[(x_{i_1} &lt; x_{j_1}) \text{ or } (x_{i_1} = x_{j_1} \text{ and }x_{i_2} &lt; x_{j_2})\right].\]</div><p>In the lower triangle of <span>$A$</span> we find the connections of each unknown <span>$x_i$</span>, which is not part of the boundary, to the unknowns <span>$x_j$</span> with <span>$x_i \leq x_j$</span>. Thus, we can express this operator for all unknowns that do not lie at the boundary. We have  <span>$S:\mathcal{L}(\mathbb{L}^s(\mathcal{A})) \rightarrow \mathcal{L}(\mathbb{L}^s(\mathcal{A})),$</span></p><div>\[(Sf)(x) = \sum_{y \in \mathbb{Z}^\text{d}} m_S^{y} \cdot f(x+\mathcal{A}y) \quad \text{ for all } x \text{ which do not lie near/at the boundary},\]</div><p>with nonzero multipliers</p><div>\[m_S^{y} = \begin{cases} m_L^{y}  &amp; \text{ if } y \leq 0 \\ 0 &amp; \text{ else} \end{cases}\]</div><p>where <span>$y \leq 0$</span> refers to the lexicographic ordering.</p><pre><code class="language-">S = alfa.CrystalOperatorCopyLowerTriangle(L)

plot(S)</code></pre><h3 id="Two-grid-analysis-with-lexicographic-Gauss-Seidel-smoothing:-1"><a class="docs-heading-anchor" href="#Two-grid-analysis-with-lexicographic-Gauss-Seidel-smoothing:-1">Two-grid analysis with lexicographic Gauss-Seidel smoothing:</a><a class="docs-heading-anchor-permalink" href="#Two-grid-analysis-with-lexicographic-Gauss-Seidel-smoothing:-1" title="Permalink"></a></h3><pre><code class="language-">f_gs = :(I-$inv($S)*$L)
f_tggs = f_cgc*f_gs
oc_tggs = alfa.OperatorComposition(f_tggs)
surfacespectrum(oc_tggs, N=40, zfilter=(0,0.7))</code></pre><h2 id="A-colored-smoother:-red-black-Gauss-Seidel-1"><a class="docs-heading-anchor" href="#A-colored-smoother:-red-black-Gauss-Seidel-1">A colored smoother: red-black Gauss-Seidel</a><a class="docs-heading-anchor-permalink" href="#A-colored-smoother:-red-black-Gauss-Seidel-1" title="Permalink"></a></h2><p>Instead of lexicographic Gauss-Seidel, we can update unknowns using a different ordering. Consider the following red-black coloring of the underlying structure:</p><p><img src="../../figs/red-black.gif" alt="title"/></p><p>Red-black Gauss-Seidel corresponds to the method which updates red unknowns before it updates black unknowns. This can be described with an error propagator of the form <span>$G_b \cdot G_r$</span> where <span>$G_x=(I - R_x^T (R_x A R_x^{T})^{-1}R_x A)$</span>, where <span>$R_x$</span>, <span>$x=r,b$</span>, is the canonical restriction to the red/black unknowns.</p><p>First, we describe the red-black crystal: We have</p><div>\[\mathbb{L}^u(C), C = \left(\begin{matrix} \mathcal{a}_1 + \mathcal{a}_2 &amp; \mathcal{a}_1 - \mathcal{a}_2 \end{matrix}\right) = \mathcal{A}\left(\begin{matrix} 1 &amp; 1 \\ 1 &amp; -1\end{matrix}\right)\]</div><p>with <span>$u=(0,\mathcal{a}_1)=:(u_\text{red} , u_\text{black})$</span>.</p><pre><code class="language-">C = A*[1 1; 1 -1]
u = [A*[0,0], A*[1,0]]
u_red = [u[1]]
u_black = [u[2]]
Cr = alfa.Crystal{2,Float64}(C, u, u_red)
Cb = alfa.Crystal{2,Float64}(C, u, u_black)

p1 = plot(Cr)
p2 = plot(Cb)
plot(p1, p2)</code></pre><p>Definition of the restriction operators:</p><pre><code class="language-">
Rr = alfa.CrystalOperator{2,Float64}(Cr)
push!(Rr, alfa.Multiplier([0 0], [1 0]))
Rb = alfa.CrystalOperator{2,Float64}(Cb)
push!(Rb, alfa.Multiplier([0 0], [0 1]))

p1 = plot(Rr)
p2 = plot(Rb)
plot(p1, p2)</code></pre><p>Defintion of the smoother:</p><pre><code class="language-">
Sr = Rr*L*Rr&#39;
Sb = Rb*L*Rb&#39;

p1 = plot(Sr)
p2 = plot(Sb)
plot(p1, p2)</code></pre><h3 id="Twogrid-analysis-with-red-black-smoothing-1"><a class="docs-heading-anchor" href="#Twogrid-analysis-with-red-black-smoothing-1">Twogrid analysis with red-black smoothing</a><a class="docs-heading-anchor-permalink" href="#Twogrid-analysis-with-red-black-smoothing-1" title="Permalink"></a></h3><pre><code class="language-">fr = :(I-$Rr&#39;*$inv($Sr)*$Rr*$L)
fb = :(I-$Rb&#39;*$inv($Sb)*$Rb*$L)
f_tgrb = f_cgc*fb*fr
oc_tgrb = alfa.OperatorComposition(f_tgrb)
surfacespectrum(oc_tgrb, N=40, zfilter=(0,0.7))</code></pre><h3 id="Alternative-construction-and-analysis-of-red-black-1"><a class="docs-heading-anchor" href="#Alternative-construction-and-analysis-of-red-black-1">Alternative construction and analysis of red-black</a><a class="docs-heading-anchor-permalink" href="#Alternative-construction-and-analysis-of-red-black-1" title="Permalink"></a></h3><p>A simpler construction can be done as follows. Note, that we (have to) use the pseudoinverse instead of the inverse as the constructed operators Sr and Sb are singular:</p><pre><code class="language-">Lrb = alfa.wrtLattice(L, L.C.L.A*[1 1; 1 -1])
Sr = alfa.CrystalOperatorCopyWithMultipliers(Lrb, idx=[1])
Sb = alfa.CrystalOperatorCopyWithMultipliers(Lrb, idx=[2])
fr = :(I-pinv($Sr)*$L)
fb = :(I-pinv($Sb)*$L)
f_tgrb = f_cgc*fb*fr
oc_tgrb = alfa.OperatorComposition(f_tgrb)
surfacespectrum(oc_tgrb, N=40, zfilter=(0,0.7))</code></pre><h2 id="Prototyping-a-two-grid-method-1"><a class="docs-heading-anchor" href="#Prototyping-a-two-grid-method-1">Prototyping a two-grid method</a><a class="docs-heading-anchor-permalink" href="#Prototyping-a-two-grid-method-1" title="Permalink"></a></h2><p>By rewriting all operators with respect to a shared <em>large</em> translationally invariance <span>$\mathcal{Z}$</span> analogously to &quot;<a href="#Obtaining-a-system-matrix-\$A\$-from-a-multiplication-operator-\$L\$">Obtaining a system matrix <span>$A$</span> from a multiplication operator <span>$L$</span></a>&quot;, we can prototype a two-grid method as follows. We stick to the Jacobi example.</p><pre><code class="language-">wrtL = alfa.Lattice{2,Float64}([1 0; 0 1])
Lm = SparseMatrixCSC(alfa.construct_matrix(L,wrtL))
Rm = SparseMatrixCSC(alfa.construct_matrix(R,wrtL))
Pm = SparseMatrixCSC(alfa.construct_matrix(P,wrtL))
Sm = SparseMatrixCSC(alfa.construct_matrix(S_jac,wrtL))
Lcm = SparseMatrixCSC(alfa.construct_matrix(Lc,wrtL))

nothing # hide</code></pre><p>We create a spy plot of all matrices:</p><pre><code class="language-">pLm = spy(Lm, c=:blues, title=&quot;Lm&quot;);
pRm = spy(Rm, c=:blues, title=&quot;Rm&quot;);
pPm = spy(Pm, c=:blues, title=&quot;Pm&quot;);
pSm = spy(Sm, c=:blues, title=&quot;Sm&quot;);
pLcm = spy(Lcm, c=:blues, title=&quot;Lcm&quot;);
plot(pLm, pRm, pPm, pSm, pLcm);</code></pre><h2 id="Definition-of-the-application-of-the-smoother-and-coarse-grid-correction-1"><a class="docs-heading-anchor" href="#Definition-of-the-application-of-the-smoother-and-coarse-grid-correction-1">Definition of the application of the smoother and coarse grid correction</a><a class="docs-heading-anchor-permalink" href="#Definition-of-the-application-of-the-smoother-and-coarse-grid-correction-1" title="Permalink"></a></h2><pre><code class="language-">SmLU = lu(Sm)
LcmLU = lu(Lcm)

function smooth(b, x)
    r = b-Lm*x
    x += 0.8*(SmLU\r)
    return x
end

function cgc(b, x)
    r = b-Lm*x
    rc = Rm*r
    xc = LcmLU\rc
    x += Pm*xc
    return x
end
nothing # hide</code></pre><h2 id="Testrun-of-the-twogrid-method.-1"><a class="docs-heading-anchor" href="#Testrun-of-the-twogrid-method.-1">Testrun of  the twogrid method.</a><a class="docs-heading-anchor-permalink" href="#Testrun-of-the-twogrid-method.-1" title="Permalink"></a></h2><pre><code class="language-">
# initialize rhs and initial guess
global x, b, casym_vec, resnorm_vec, num_iter
n = size(Lm,1);
x = zeros(n);
b = Lm*rand(n);
b = b/norm(b);

casym_vec = [1.0]
resnorm_vec = [1.0]

num_iter = 0

while resnorm_vec[end] &gt; 1e-13 &amp;&amp; num_iter &lt; 150
    global x, b, casym_vec, resnorm_vec, num_iter
    num_iter = num_iter + 1
    x = smooth(b,x)
    x = cgc(b,x)
    push!(resnorm_vec, norm(b - Lm*x))
    push!(casym_vec, resnorm_vec[end]/resnorm_vec[end-1])
end

# plot convergence behavior.
plot(resnorm_vec, yaxis=:log, xlabel=&quot;iteration&quot;, ylabel=&quot;residual norm&quot;, title=&quot;measured asymptotic convrate=&quot;*string(casym_vec[end])*&quot;\n conv.rate from analysis: &quot;*string(abs(alfa.eigvals(oc_tgj,N=20)[end-1])) )
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../example_02/">Example 2: Colored overlapping smoother for graphene »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 9 June 2020 08:26">Tuesday 9 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
